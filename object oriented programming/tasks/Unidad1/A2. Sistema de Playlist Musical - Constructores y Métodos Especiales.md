# A2. Sistema de Playlist Musical - Constructores y MÃ©todos Especiales

## ğŸ“‹ DescripciÃ³n de la Actividad

Esta actividad implementa un sistema completo de gestiÃ³n de playlists musicales, aplicando conceptos avanzados de constructores, mÃ©todos especiales (dunder methods), mÃ©todos de clase y mÃ©todos estÃ¡ticos. El sistema permite gestionar canciones individuales y crear playlists con mÃºltiples funcionalidades.

## ğŸ¯ Objetivos de Aprendizaje

- Implementar constructores alternativos con `@classmethod`
- Utilizar mÃ©todos especiales para sobrecarga de operadores
- Crear propiedades calculadas con `@property`
- Aplicar mÃ©todos estÃ¡ticos para funciones auxiliares
- Hacer objetos iterables e indexables
- Implementar comparaciones personalizadas

## ğŸ“ Requerimientos

### Clase `Cancion`

**Atributos:**

- `titulo` (string): TÃ­tulo de la canciÃ³n
- `artista` (string): Nombre del artista
- `duracion` (int): DuraciÃ³n en segundos
- `genero` (string): GÃ©nero musical

**MÃ©todos especiales:**

- `__str__`: RepresentaciÃ³n legible
- `__eq__`: ComparaciÃ³n por igualdad
- `__lt__`: ComparaciÃ³n por duraciÃ³n (para ordenamiento)

**MÃ©todos de clase:**

- `desde_string(texto)`: Constructor alternativo desde string "titulo - artista - duracion"

**Propiedades:**

- `duracion_formateada`: Retorna duraciÃ³n en formato "MM:SS"

### Clase `Playlist`

**Atributos:**

- `nombre` (string): Nombre de la playlist
- `canciones` (list): Lista de objetos Cancion

**MÃ©todos:**

- `agregar(cancion)`: AÃ±ade una canciÃ³n
- `eliminar(titulo)`: Elimina canciÃ³n por tÃ­tulo
- `mezclar()`: Ordena aleatoriamente
- `duracion_total()`: Suma total de duraciÃ³n

**MÃ©todos especiales:**

- `__len__`: Retorna cantidad de canciones
- `__iter__`: Permite iterar sobre canciones
- `__getitem__`: Acceso por Ã­ndice
- `__add__`: Unir dos playlists

## ğŸ’» SoluciÃ³n Completa

```python
# playlist_musical.py

import random
from typing import List, Optional

class Cancion:
    """Representa una canciÃ³n con sus metadatos y operaciones"""

    # Atributo de clase: gÃ©neros vÃ¡lidos
    GENEROS_VALIDOS = {
        'Rock', 'Pop', 'Jazz', 'ClÃ¡sica', 'ElectrÃ³nica',
        'Hip Hop', 'Reggaeton', 'Salsa', 'Blues', 'Country',
        'R&B', 'Metal', 'Folk', 'Indie', 'Otro'
    }

    def __init__(self, titulo: str, artista: str, duracion: int, genero: str = "Otro"):
        """
        Inicializa una canciÃ³n con sus metadatos.

        Args:
            titulo (str): TÃ­tulo de la canciÃ³n
            artista (str): Nombre del artista o banda
            duracion (int): DuraciÃ³n en segundos
            genero (str, optional): GÃ©nero musical. Por defecto "Otro".

        Raises:
            ValueError: Si la duraciÃ³n es negativa o el gÃ©nero no es vÃ¡lido
        """
        if duracion < 0:
            raise ValueError("La duraciÃ³n no puede ser negativa")

        if genero not in self.GENEROS_VALIDOS:
            print(f"âš  Advertencia: '{genero}' no es un gÃ©nero reconocido. Usando 'Otro'.")
            genero = "Otro"

        self.titulo = titulo.strip()
        self.artista = artista.strip()
        self.duracion = duracion
        self.genero = genero
        self.reproducciones = 0
        self.favorita = False

    @property
    def duracion_formateada(self) -> str:
        """
        Retorna la duraciÃ³n en formato MM:SS.

        Returns:
            str: DuraciÃ³n formateada (ej: "03:45")
        """
        minutos = self.duracion // 60
        segundos = self.duracion % 60
        return f"{minutos:02d}:{segundos:02d}"

    @classmethod
    def desde_string(cls, texto: str) -> 'Cancion':
        """
        Constructor alternativo: crea una canciÃ³n desde un string.

        Formato esperado: "titulo - artista - duracion_segundos - genero"
        Ejemplo: "Bohemian Rhapsody - Queen - 354 - Rock"

        Args:
            texto (str): String con la informaciÃ³n de la canciÃ³n

        Returns:
            Cancion: Nueva instancia de Cancion

        Raises:
            ValueError: Si el formato es invÃ¡lido
        """
        try:
            partes = [p.strip() for p in texto.split(' - ')]

            if len(partes) == 3:
                titulo, artista, duracion = partes
                return cls(titulo, artista, int(duracion))
            elif len(partes) == 4:
                titulo, artista, duracion, genero = partes
                return cls(titulo, artista, int(duracion), genero)
            else:
                raise ValueError("Formato invÃ¡lido")

        except (ValueError, IndexError) as e:
            raise ValueError(
                f"Formato invÃ¡lido. Use: 'titulo - artista - segundos [- genero]'\n"
                f"Ejemplo: 'Bohemian Rhapsody - Queen - 354 - Rock'"
            ) from e

    @classmethod
    def desde_minutos(cls, titulo: str, artista: str, minutos: float, genero: str = "Otro") -> 'Cancion':
        """
        Constructor alternativo: crea una canciÃ³n especificando duraciÃ³n en minutos.

        Args:
            titulo (str): TÃ­tulo de la canciÃ³n
            artista (str): Artista
            minutos (float): DuraciÃ³n en minutos (ej: 3.5 = 3 minutos 30 segundos)
            genero (str, optional): GÃ©nero musical

        Returns:
            Cancion: Nueva instancia
        """
        segundos = int(minutos * 60)
        return cls(titulo, artista, segundos, genero)

    @staticmethod
    def segundos_a_formato(segundos: int) -> str:
        """
        Convierte segundos a formato MM:SS.

        Args:
            segundos (int): Cantidad de segundos

        Returns:
            str: Formato MM:SS
        """
        minutos = segundos // 60
        segs = segundos % 60
        return f"{minutos:02d}:{segs:02d}"

    @staticmethod
    def formato_a_segundos(tiempo: str) -> int:
        """
        Convierte formato MM:SS a segundos.

        Args:
            tiempo (str): Tiempo en formato MM:SS

        Returns:
            int: Cantidad de segundos
        """
        partes = tiempo.split(':')
        if len(partes) == 2:
            minutos, segundos = map(int, partes)
            return minutos * 60 + segundos
        raise ValueError("Formato invÃ¡lido. Use MM:SS")

    def reproducir(self):
        """Incrementa el contador de reproducciones"""
        self.reproducciones += 1

    def marcar_favorita(self):
        """Marca la canciÃ³n como favorita"""
        self.favorita = True

    def desmarcar_favorita(self):
        """Desmarca la canciÃ³n como favorita"""
        self.favorita = False

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MÃ‰TODOS ESPECIALES (DUNDER METHODS)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def __str__(self) -> str:
        """RepresentaciÃ³n legible para usuarios"""
        favorito = "â˜…" if self.favorita else "â˜†"
        return f"{favorito} {self.titulo} - {self.artista} [{self.duracion_formateada}]"

    def __repr__(self) -> str:
        """RepresentaciÃ³n tÃ©cnica para desarrolladores"""
        return f"Cancion('{self.titulo}', '{self.artista}', {self.duracion}, '{self.genero}')"

    def __eq__(self, otra) -> bool:
        """
        Compara dos canciones por igualdad.
        Dos canciones son iguales si tienen el mismo tÃ­tulo y artista.
        """
        if not isinstance(otra, Cancion):
            return False
        return (self.titulo.lower() == otra.titulo.lower() and
                self.artista.lower() == otra.artista.lower())

    def __lt__(self, otra) -> bool:
        """
        Compara canciones por duraciÃ³n (para ordenamiento).
        Permite usar sort() y sorted().
        """
        if not isinstance(otra, Cancion):
            return NotImplemented
        return self.duracion < otra.duracion

    def __le__(self, otra) -> bool:
        """Menor o igual (<=)"""
        return self.duracion <= otra.duracion

    def __gt__(self, otra) -> bool:
        """Mayor que (>)"""
        return self.duracion > otra.duracion

    def __ge__(self, otra) -> bool:
        """Mayor o igual (>=)"""
        return self.duracion >= otra.duracion

    def __hash__(self):
        """Permite usar la canciÃ³n en sets y como clave de diccionarios"""
        return hash((self.titulo.lower(), self.artista.lower()))


class Playlist:
    """Gestiona una colecciÃ³n de canciones"""

    def __init__(self, nombre: str, descripcion: str = ""):
        """
        Inicializa una playlist vacÃ­a.

        Args:
            nombre (str): Nombre de la playlist
            descripcion (str, optional): DescripciÃ³n de la playlist
        """
        self.nombre = nombre
        self.descripcion = descripcion
        self.canciones: List[Cancion] = []
        self._indice_actual = 0

    def agregar(self, cancion: Cancion) -> bool:
        """
        Agrega una canciÃ³n a la playlist.

        Args:
            cancion (Cancion): CanciÃ³n a agregar

        Returns:
            bool: True si se agregÃ³, False si ya existÃ­a
        """
        if not isinstance(cancion, Cancion):
            raise TypeError("Solo se pueden agregar objetos de tipo Cancion")

        if cancion in self.canciones:
            print(f"âš  '{cancion.titulo}' ya estÃ¡ en la playlist")
            return False

        self.canciones.append(cancion)
        print(f"âœ“ '{cancion.titulo}' agregada a '{self.nombre}'")
        return True

    def eliminar(self, titulo: str) -> bool:
        """
        Elimina una canciÃ³n por su tÃ­tulo.

        Args:
            titulo (str): TÃ­tulo de la canciÃ³n a eliminar

        Returns:
            bool: True si se eliminÃ³, False si no se encontrÃ³
        """
        for i, cancion in enumerate(self.canciones):
            if cancion.titulo.lower() == titulo.lower():
                eliminada = self.canciones.pop(i)
                print(f"âœ“ '{eliminada.titulo}' eliminada de '{self.nombre}'")
                return True

        print(f"âœ— No se encontrÃ³ '{titulo}' en la playlist")
        return False

    def buscar(self, termino: str) -> List[Cancion]:
        """
        Busca canciones por tÃ­tulo o artista.

        Args:
            termino (str): TÃ©rmino de bÃºsqueda

        Returns:
            List[Cancion]: Lista de canciones que coinciden
        """
        termino_lower = termino.lower()
        resultados = [
            c for c in self.canciones
            if termino_lower in c.titulo.lower() or termino_lower in c.artista.lower()
        ]
        return resultados

    def mezclar(self):
        """Ordena las canciones aleatoriamente"""
        random.shuffle(self.canciones)
        print(f"ğŸ”€ Playlist '{self.nombre}' mezclada")

    def ordenar_por_titulo(self):
        """Ordena alfabÃ©ticamente por tÃ­tulo"""
        self.canciones.sort(key=lambda c: c.titulo.lower())
        print(f"âœ“ Ordenada por tÃ­tulo")

    def ordenar_por_artista(self):
        """Ordena alfabÃ©ticamente por artista"""
        self.canciones.sort(key=lambda c: c.artista.lower())
        print(f"âœ“ Ordenada por artista")

    def ordenar_por_duracion(self):
        """Ordena por duraciÃ³n (usa __lt__ de Cancion)"""
        self.canciones.sort()
        print(f"âœ“ Ordenada por duraciÃ³n")

    def filtrar_por_genero(self, genero: str) -> List[Cancion]:
        """
        Filtra canciones por gÃ©nero.

        Args:
            genero (str): GÃ©nero a filtrar

        Returns:
            List[Cancion]: Canciones del gÃ©nero especificado
        """
        return [c for c in self.canciones if c.genero == genero]

    def obtener_favoritas(self) -> List[Cancion]:
        """Retorna solo las canciones marcadas como favoritas"""
        return [c for c in self.canciones if c.favorita]

    def duracion_total(self) -> int:
        """
        Calcula la duraciÃ³n total de la playlist en segundos.

        Returns:
            int: DuraciÃ³n total en segundos
        """
        return sum(cancion.duracion for cancion in self.canciones)

    @property
    def duracion_formateada(self) -> str:
        """Retorna la duraciÃ³n total en formato HH:MM:SS"""
        total_segundos = self.duracion_total()
        horas = total_segundos // 3600
        minutos = (total_segundos % 3600) // 60
        segundos = total_segundos % 60

        if horas > 0:
            return f"{horas:02d}:{minutos:02d}:{segundos:02d}"
        else:
            return f"{minutos:02d}:{segundos:02d}"

    def estadisticas(self) -> dict:
        """Retorna estadÃ­sticas de la playlist"""
        if not self.canciones:
            return {"error": "Playlist vacÃ­a"}

        generos = {}
        for cancion in self.canciones:
            generos[cancion.genero] = generos.get(cancion.genero, 0) + 1

        duracion_promedio = self.duracion_total() // len(self.canciones)

        return {
            "total_canciones": len(self.canciones),
            "duracion_total": self.duracion_formateada,
            "duracion_promedio": Cancion.segundos_a_formato(duracion_promedio),
            "generos": generos,
            "favoritas": len(self.obtener_favoritas()),
            "cancion_mas_larga": max(self.canciones, key=lambda c: c.duracion),
            "cancion_mas_corta": min(self.canciones, key=lambda c: c.duracion)
        }

    @classmethod
    def desde_lista(cls, nombre: str, lista_canciones: List[Cancion], descripcion: str = "") -> 'Playlist':
        """
        Constructor alternativo: crea playlist desde una lista de canciones.

        Args:
            nombre (str): Nombre de la playlist
            lista_canciones (List[Cancion]): Lista de canciones
            descripcion (str, optional): DescripciÃ³n

        Returns:
            Playlist: Nueva playlist con las canciones
        """
        playlist = cls(nombre, descripcion)
        for cancion in lista_canciones:
            playlist.agregar(cancion)
        return playlist

    @classmethod
    def desde_archivo(cls, ruta: str) -> 'Playlist':
        """
        Constructor alternativo: carga playlist desde archivo de texto.

        Formato del archivo:
        Primera lÃ­nea: nombre de la playlist
        Segunda lÃ­nea: descripciÃ³n (opcional)
        Resto: canciones en formato "titulo - artista - duracion - genero"

        Args:
            ruta (str): Ruta al archivo

        Returns:
            Playlist: Playlist cargada
        """
        try:
            with open(ruta, 'r', encoding='utf-8') as archivo:
                lineas = archivo.readlines()

                if len(lineas) < 2:
                    raise ValueError("Archivo incompleto")

                nombre = lineas[0].strip()
                descripcion = lineas[1].strip()

                playlist = cls(nombre, descripcion)

                for linea in lineas[2:]:
                    linea = linea.strip()
                    if linea and not linea.startswith('#'):
                        try:
                            cancion = Cancion.desde_string(linea)
                            playlist.agregar(cancion)
                        except ValueError as e:
                            print(f"âš  Error en lÃ­nea '{linea}': {e}")

                return playlist

        except FileNotFoundError:
            raise FileNotFoundError(f"No se encontrÃ³ el archivo: {ruta}")
        except Exception as e:
            raise Exception(f"Error al cargar playlist: {e}")

    def guardar_en_archivo(self, ruta: str):
        """
        Guarda la playlist en un archivo de texto.

        Args:
            ruta (str): Ruta donde guardar el archivo
        """
        with open(ruta, 'w', encoding='utf-8') as archivo:
            archivo.write(f"{self.nombre}\n")
            archivo.write(f"{self.descripcion}\n")
            archivo.write(f"# Total de canciones: {len(self.canciones)}\n")
            archivo.write(f"# DuraciÃ³n total: {self.duracion_formateada}\n")
            archivo.write("#\n")

            for cancion in self.canciones:
                archivo.write(
                    f"{cancion.titulo} - {cancion.artista} - "
                    f"{cancion.duracion} - {cancion.genero}\n"
                )

        print(f"âœ“ Playlist guardada en '{ruta}'")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MÃ‰TODOS ESPECIALES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def __len__(self) -> int:
        """Retorna la cantidad de canciones en la playlist"""
        return len(self.canciones)

    def __iter__(self):
        """Permite iterar sobre las canciones"""
        self._indice_actual = 0
        return self

    def __next__(self) -> Cancion:
        """Retorna la siguiente canciÃ³n en la iteraciÃ³n"""
        if self._indice_actual < len(self.canciones):
            cancion = self.canciones[self._indice_actual]
            self._indice_actual += 1
            return cancion
        else:
            raise StopIteration

    def __getitem__(self, indice) -> Cancion:
        """
        Permite acceder a canciones por Ã­ndice o slice.

        Ejemplos:
            playlist[0]      # Primera canciÃ³n
            playlist[-1]     # Ãšltima canciÃ³n
            playlist[1:3]    # Canciones 1 y 2
        """
        return self.canciones[indice]

    def __contains__(self, item) -> bool:
        """
        Verifica si una canciÃ³n o tÃ­tulo estÃ¡ en la playlist.

        Permite usar el operador 'in':
            if cancion in playlist: ...
            if "Bohemian Rhapsody" in playlist: ...
        """
        if isinstance(item, Cancion):
            return item in self.canciones
        elif isinstance(item, str):
            return any(c.titulo.lower() == item.lower() for c in self.canciones)
        return False

    def __add__(self, otra) -> 'Playlist':
        """
        Une dos playlists en una nueva.

        Permite usar el operador +:
            nueva_playlist = playlist1 + playlist2
        """
        if not isinstance(otra, Playlist):
            raise TypeError("Solo se pueden sumar Playlists")

        nueva_nombre = f"{self.nombre} + {otra.nombre}"
        nueva = Playlist(nueva_nombre, f"UniÃ³n de '{self.nombre}' y '{otra.nombre}'")

        # Agregar canciones sin duplicados
        for cancion in self.canciones + otra.canciones:
            if cancion not in nueva.canciones:
                nueva.canciones.append(cancion)

        return nueva

    def __iadd__(self, otra) -> 'Playlist':
        """
        Agrega canciones de otra playlist a esta.

        Permite usar el operador +=:
            playlist1 += playlist2
        """
        if not isinstance(otra, Playlist):
            raise TypeError("Solo se pueden sumar Playlists")

        for cancion in otra.canciones:
            if cancion not in self.canciones:
                self.canciones.append(cancion)

        return self

    def __str__(self) -> str:
        """RepresentaciÃ³n legible de la playlist"""
        return (f"ğŸµ Playlist: {self.nombre}\n"
                f"   Canciones: {len(self.canciones)}\n"
                f"   DuraciÃ³n: {self.duracion_formateada}")

    def __repr__(self) -> str:
        """RepresentaciÃ³n tÃ©cnica"""
        return f"Playlist('{self.nombre}', canciones={len(self.canciones)})"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N PRINCIPAL Y DEMOSTRACIONES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """DemostraciÃ³n completa del sistema de playlists"""

    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘            SISTEMA DE PLAYLIST MUSICAL                       â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. CREAR CANCIONES DE DIVERSAS FORMAS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("1. CREANDO CANCIONES")
    print("â”€" * 63)

    # Constructor normal
    c1 = Cancion("Bohemian Rhapsody", "Queen", 354, "Rock")
    c2 = Cancion("Billie Jean", "Michael Jackson", 294, "Pop")
    c3 = Cancion("Stairway to Heaven", "Led Zeppelin", 482, "Rock")

    # Constructor desde string
    c4 = Cancion.desde_string("Hotel California - Eagles - 391 - Rock")
    c5 = Cancion.desde_string("Imagine - John Lennon - 183 - Pop")

    # Constructor desde minutos
    c6 = Cancion.desde_minutos("Smells Like Teen Spirit", "Nirvana", 5.01, "Rock")
    c7 = Cancion.desde_minutos("Sweet Child O' Mine", "Guns N' Roses", 5.56, "Rock")

    # MÃ¡s canciones
    c8 = Cancion("Thriller", "Michael Jackson", 357, "Pop")
    c9 = Cancion("November Rain", "Guns N' Roses", 537, "Rock")
    c10 = Cancion("Hey Jude", "The Beatles", 431, "Rock")

    canciones = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10]

    print(f"âœ“ {len(canciones)} canciones creadas\n")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. CREAR PLAYLIST Y AGREGAR CANCIONES
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("2. CREANDO PLAYLIST")
    print("â”€" * 63)

    playlist_rock = Playlist("Rock Classics", "Las mejores canciones de rock clÃ¡sico")

    for cancion in [c1, c3, c4, c6, c7, c9, c10]:
        playlist_rock.agregar(cancion)

    print(f"\n{playlist_rock}\n")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. DEMOSTRAR MÃ‰TODOS ESPECIALES
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n3. MÃ‰TODOS ESPECIALES")
    print("â”€" * 63)

    # __len__
    print(f"Cantidad de canciones: {len(playlist_rock)}")

    # __getitem__
    print(f"Primera canciÃ³n: {playlist_rock[0]}")
    print(f"Ãšltima canciÃ³n: {playlist_rock[-1]}")

    # __contains__
    print(f"\nÂ¿'Bohemian Rhapsody' estÃ¡ en la playlist? {c1 in playlist_rock}")
    print(f"Â¿'Hotel California' estÃ¡ en la playlist? {'Hotel California' in playlist_rock}")

    # __iter__
    print("\nğŸ“‹ Iterando sobre la playlist:")
    for i, cancion in enumerate(playlist_rock, 1):
        print(f"  {i}. {cancion}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. OPERACIONES DE COMPARACIÃ“N Y ORDENAMIENTO
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n4. COMPARACIÃ“N Y ORDENAMIENTO")
    print("â”€" * 63)

    print(f"Â¿{c1.titulo} es mÃ¡s larga que {c5.titulo}?")
    print(f"  {c1.duracion_formateada} > {c5.duracion_formateada} = {c1 > c5}")

    # Marcar favoritas
    c1.marcar_favorita()
    c4.marcar_favorita()
    c9.marcar_favorita()

    print("\nğŸ“Œ Canciones favoritas:")
    for cancion in playlist_rock.obtener_favoritas():
        print(f"  {cancion}")

    # Ordenar
    print("\nğŸ”½ Ordenando por duraciÃ³n:")
    playlist_rock.ordenar_por_duracion()
    for i, cancion in enumerate(playlist_rock, 1):
        print(f"  {i}. {cancion.titulo:<30} [{cancion.duracion_formateada}]")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. CREAR OTRA PLAYLIST Y UNIRLAS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n5. UNIÃ“N DE PLAYLISTS")
    print("â”€" * 63)

    playlist_pop = Playlist.desde_lista(
        "Pop Legends",
        [c2, c5, c8],
        "Los mejores Ã©xitos pop"
    )

    print(f"\n{playlist_pop}")

    # Unir playlists con +
    playlist_mixta = playlist_rock + playlist_pop
    print(f"\nâœ“ Playlists unidas:")
    print(f"{playlist_mixta}")
    print(f"  Canciones totales (sin duplicados): {len(playlist_mixta)}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. ESTADÃSTICAS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n6. ESTADÃSTICAS DE LA PLAYLIST")
    print("â”€" * 63)

    stats = playlist_rock.estadisticas()

    print(f"""
ğŸ“Š EstadÃ­sticas de '{playlist_rock.nombre}':
  Total de canciones:    {stats['total_canciones']}
  DuraciÃ³n total:        {stats['duracion_total']}
  DuraciÃ³n promedio:     {stats['duracion_promedio']}
  Canciones favoritas:   {stats['favoritas']}

  GÃ©neros:
    """)

    for genero, cantidad in stats['generos'].items():
        print(f"    â€¢ {genero}: {cantidad} canciones")

    print(f"""
  CanciÃ³n mÃ¡s larga:     {stats['cancion_mas_larga'].titulo} [{stats['cancion_mas_larga'].duracion_formateada}]
  CanciÃ³n mÃ¡s corta:     {stats['cancion_mas_corta'].titulo} [{stats['cancion_mas_corta'].duracion_formateada}]
    """)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7. BUSCAR Y FILTRAR
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n7. BÃšSQUEDA Y FILTRADO")
    print("â”€" * 63)

    # Buscar por tÃ©rmino
    resultados = playlist_rock.buscar("Guns")
    print(f"\nğŸ” BÃºsqueda 'Guns': {len(resultados)} resultados")
    for cancion in resultados:
        print(f"  â€¢ {cancion}")

    # Filtrar por gÃ©nero
    rock_songs = playlist_mixta.filtrar_por_genero("Rock")
    print(f"\nğŸ¸ Canciones de Rock: {len(rock_songs)}")
    for cancion in rock_songs[:3]:  # Mostrar solo 3
        print(f"  â€¢ {cancion}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8. MEZCLAR Y REORGANIZAR
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n8. MEZCLAR PLAYLIST")
    print("â”€" * 63)

    print("Orden actual (primeras 3):")
    for i in range(3):
        print(f"  {i+1}. {playlist_rock[i].titulo}")

    playlist_rock.mezclar()

    print("\nDespuÃ©s de mezclar (primeras 3):")
    for i in range(3):
        print(f"  {i+1}. {playlist_rock[i].titulo}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 9. GUARDAR Y CARGAR DESDE ARCHIVO
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n9. GUARDAR Y CARGAR DESDE ARCHIVO")
    print("â”€" * 63)

    # Guardar
    nombre_archivo = "mi_playlist_rock.txt"
    playlist_rock.guardar_en_archivo(nombre_archivo)

    # Cargar
    try:
        playlist_cargada = Playlist.desde_archivo(nombre_archivo)
        print(f"âœ“ Playlist cargada desde archivo:")
        print(f"  {playlist_cargada}")
        print(f"  Primeras 3 canciones:")
        for i in range(min(3, len(playlist_cargada))):
            print(f"    {i+1}. {playlist_cargada[i]}")
    except FileNotFoundError:
        print(f"âœ— No se pudo cargar el archivo (se crearÃ¡ al guardar)")

    print("\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


if __name__ == "__main__":
    main()
```

## ğŸ” ExplicaciÃ³n Detallada del CÃ³digo

### 1. MÃ©todos Especiales en `Cancion`

**`__eq__` - ComparaciÃ³n por igualdad**

```python
def __eq__(self, otra) -> bool:
    return (self.titulo.lower() == otra.titulo.lower() and
            self.artista.lower() == otra.artista.lower())
```

- Permite usar `==` entre canciones
- Compara por tÃ­tulo y artista (case-insensitive)
- Ãštil para evitar duplicados

**`__lt__` - Menor que (para ordenamiento)**

```python
def __lt__(self, otra) -> bool:
    return self.duracion < otra.duracion
```

- Permite usar `sort()` y `sorted()`
- Compara por duraciÃ³n
- Implementa el resto de comparadores (`__le__`, `__gt__`, `__ge__`)

**`__hash__` - Para usar en sets y diccionarios**

```python
def __hash__(self):
    return hash((self.titulo.lower(), self.artista.lower()))
```

- Permite agregar canciones a sets
- Usar canciones como claves de diccionarios
- Debe ser consistente con `__eq__`

### 2. Constructores Alternativos

**`@classmethod desde_string`**

```python
@classmethod
def desde_string(cls, texto: str) -> 'Cancion':
    partes = [p.strip() for p in texto.split(' - ')]
    titulo, artista, duracion, genero = partes
    return cls(titulo, artista, int(duracion), genero)
```

- Recibe `cls` en lugar de `self`
- Parsea un string y crea la instancia
- Maneja errores de formato

**`@classmethod desde_minutos`**

- Convierte minutos a segundos
- MÃ¡s intuitivo para el usuario
- Retorna instancia creada con `cls()`

### 3. MÃ©todos Especiales en `Playlist`

**`__iter__` y `__next__` - Hacer iterable**

```python
def __iter__(self):
    self._indice_actual = 0
    return self

def __next__(self) -> Cancion:
    if self._indice_actual < len(self.canciones):
        cancion = self.canciones[self._indice_actual]
        self._indice_actual += 1
        return cancion
    raise StopIteration
```

- Permite usar `for cancion in playlist:`
- Mantiene estado interno con `_indice_actual`
- Lanza `StopIteration` al finalizar

**`__getitem__` - Acceso por Ã­ndice**

```python
def __getitem__(self, indice) -> Cancion:
    return self.canciones[indice]
```

- Permite `playlist[0]`, `playlist[-1]`
- Soporta slicing: `playlist[1:3]`
- Delega a la lista interna

**`__contains__` - Operador `in`**

```python
def __contains__(self, item) -> bool:
    if isinstance(item, Cancion):
        return item in self.canciones
    elif isinstance(item, str):
        return any(c.titulo.lower() == item.lower() for c in self.canciones)
```

- Permite `if cancion in playlist:`
- Acepta tanto objetos `Cancion` como strings
- BÃºsqueda flexible

**`__add__` - Unir playlists**

```python
def __add__(self, otra) -> 'Playlist':
    nueva = Playlist(f"{self.nombre} + {otra.nombre}")
    # Agregar canciones sin duplicados
    for cancion in self.canciones + otra.canciones:
        if cancion not in nueva.canciones:
            nueva.canciones.append(cancion)
    return nueva
```

- Permite `playlist3 = playlist1 + playlist2`
- Crea nueva playlist (no modifica originales)
- Elimina duplicados

### 4. Propiedades Calculadas

**`@property duracion_formateada`**

```python
@property
def duracion_formateada(self) -> str:
    minutos = self.duracion // 60
    segundos = self.duracion % 60
    return f"{minutos:02d}:{segundos:02d}"
```

- Se accede como atributo: `cancion.duracion_formateada`
- Calcula el valor cada vez que se accede
- No se puede asignar (solo lectura)

### 5. MÃ©todos EstÃ¡ticos

**`@staticmethod segundos_a_formato`**

```python
@staticmethod
def segundos_a_formato(segundos: int) -> str:
    minutos = segundos // 60
    segs = segundos % 60
    return f"{minutos:02d}:{segs:02d}"
```

- No recibe `self` ni `cls`
- FunciÃ³n auxiliar relacionada con la clase
- Se puede llamar sin instancia: `Cancion.segundos_a_formato(180)`

## ğŸ“Š Ejemplo de Salida

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            SISTEMA DE PLAYLIST MUSICAL                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. CREANDO CANCIONES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ 10 canciones creadas

2. CREANDO PLAYLIST
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ 'Bohemian Rhapsody' agregada a 'Rock Classics'
âœ“ 'Stairway to Heaven' agregada a 'Rock Classics'
âœ“ 'Hotel California' agregada a 'Rock Classics'
...

ğŸµ Playlist: Rock Classics
   Canciones: 7
   DuraciÃ³n: 47:52


3. MÃ‰TODOS ESPECIALES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Cantidad de canciones: 7
Primera canciÃ³n: â˜† Bohemian Rhapsody - Queen [05:54]
Ãšltima canciÃ³n: â˜† Hey Jude - The Beatles [07:11]

Â¿'Bohemian Rhapsody' estÃ¡ en la playlist? True
Â¿'Hotel California' estÃ¡ en la playlist? True
```

## âœ… Puntos Clave para Replicar

1. **Type hints**: Usar anotaciones de tipo para claridad
2. **Validaciones**: Verificar tipos y valores en constructores
3. **MÃ©todos especiales**: Implementar para comportamiento natural
4. **Constructores alternativos**: Usar `@classmethod` para flexibilidad
5. **Propiedades**: Calcular valores derivados con `@property`
6. **MÃ©todos estÃ¡ticos**: Funciones auxiliares con `@staticmethod`
7. **Iteradores**: Implementar `__iter__` y `__next__` para iteraciÃ³n
8. **Operadores**: Sobrecargar con mÃ©todos especiales (`__add__`, `__eq__`, etc.)

## ğŸ“ Conceptos Aplicados

- âœ… Constructores mÃºltiples con `@classmethod`
- âœ… MÃ©todos especiales (dunder methods)
- âœ… Sobrecarga de operadores
- âœ… Propiedades calculadas con `@property`
- âœ… MÃ©todos estÃ¡ticos
- âœ… Iteradores personalizados
- âœ… Type hints
- âœ… Manejo de archivos
- âœ… List comprehensions
- âœ… Validaciones y excepciones

## ğŸš€ Extensiones Posibles

1. Agregar reproducciÃ³n con threading
2. Implementar cola de reproducciÃ³n
3. Agregar letras de canciones
4. Sistema de calificaciones
5. IntegraciÃ³n con APIs de mÃºsica (Spotify, etc.)
6. VisualizaciÃ³n de estadÃ­sticas con grÃ¡ficos
7. Sistema de recomendaciones
