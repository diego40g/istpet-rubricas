# A7. ImplementaciÃ³n de Patrones de DiseÃ±o ClÃ¡sicos

## ğŸ“‹ DescripciÃ³n de la Actividad

Esta actividad implementa los **patrones de diseÃ±o mÃ¡s importantes** en Python de manera prÃ¡ctica y real. Se desarrolla un **sistema de gestiÃ³n de pedidos de restaurante** que integra mÃºltiples patrones: Singleton, Factory, Builder, Strategy, Observer y Decorator. Cada patrÃ³n resuelve un problema especÃ­fico y demuestra su valor en un contexto realista.

## ğŸ¯ Objetivos de Aprendizaje

- Comprender cuÃ¡ndo y por quÃ© usar cada patrÃ³n
- Implementar patrones creacionales (Singleton, Factory, Builder)
- Implementar patrones de comportamiento (Strategy, Observer)
- Implementar patrones estructurales (Decorator)
- Integrar mÃºltiples patrones en un sistema cohesivo
- Identificar problemas que resuelve cada patrÃ³n

## ğŸ“š Los 6 Patrones Implementados

### 1. **Singleton** (Creacional)

**Problema**: Necesito una Ãºnica instancia de configuraciÃ³n compartida globalmente
**SoluciÃ³n**: Garantizar una sola instancia con acceso global

### 2. **Factory Method** (Creacional)

**Problema**: Crear diferentes tipos de platos sin acoplar cÃ³digo a clases concretas
**SoluciÃ³n**: Delegar la creaciÃ³n a mÃ©todos especializados

### 3. **Builder** (Creacional)

**Problema**: Construir pedidos complejos con mÃºltiples opciones paso a paso
**SoluciÃ³n**: Separar construcciÃ³n de representaciÃ³n

### 4. **Strategy** (Comportamiento)

**Problema**: MÃºltiples mÃ©todos de pago con lÃ³gicas diferentes
**SoluciÃ³n**: Encapsular algoritmos intercambiables

### 5. **Observer** (Comportamiento)

**Problema**: Notificar a mÃºltiples sistemas cuando cambia estado del pedido
**SoluciÃ³n**: PatrÃ³n publicador-suscriptor

### 6. **Decorator** (Estructural)

**Problema**: Agregar extras a platos sin modificar clases existentes
**SoluciÃ³n**: Envolver objetos con funcionalidad adicional

## ğŸ’» SoluciÃ³n Completa

### Parte 1: PatrÃ³n Singleton - ConfiguraciÃ³n del Sistema

```python
# sistema_restaurante.py
# Sistema completo de gestiÃ³n de pedidos con patrones de diseÃ±o

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional, Callable
from enum import Enum
from functools import wraps


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATRÃ“N SINGLETON: ConfiguraciÃ³n Global
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ConfiguracionRestaurante:
    """
    ğŸ”¹ PATRÃ“N: Singleton

    Â¿Por quÃ©? Necesitamos una Ãºnica instancia de configuraciÃ³n
    compartida por todo el sistema.

    Beneficios:
    - Acceso global controlado
    - GarantÃ­a de una sola instancia
    - InicializaciÃ³n lazy
    """

    _instancia: Optional['ConfiguracionRestaurante'] = None
    _inicializada: bool = False

    def __new__(cls):
        """Controla la creaciÃ³n de instancias"""
        if cls._instancia is None:
            cls._instancia = super().__new__(cls)
        return cls._instancia

    def __init__(self):
        """Solo inicializa una vez"""
        if not ConfiguracionRestaurante._inicializada:
            self.nombre_restaurante = "Restaurante El Buen Sabor"
            self.moneda = "MXN"
            self.iva = 0.16
            self.propina_sugerida = 0.15
            self.tiempo_preparacion_base = 15  # minutos
            self.max_items_por_pedido = 20
            self.modo_debug = True
            ConfiguracionRestaurante._inicializada = True

    def calcular_total_con_iva(self, subtotal: float) -> float:
        """Calcula total con IVA"""
        return subtotal * (1 + self.iva)

    def calcular_propina_sugerida(self, total: float) -> float:
        """Calcula propina sugerida"""
        return total * self.propina_sugerida

    def __repr__(self) -> str:
        return f"ConfiguraciÃ³n({self.nombre_restaurante})"


# Prueba del Singleton
def probar_singleton():
    """Demuestra que siempre es la misma instancia"""
    config1 = ConfiguracionRestaurante()
    config2 = ConfiguracionRestaurante()

    print(f"Â¿Son la misma instancia? {config1 is config2}")  # True
    print(f"ID config1: {id(config1)}")
    print(f"ID config2: {id(config2)}")  # Mismo ID


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODELOS BASE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CategoriaPlato(Enum):
    """CategorÃ­as de platos"""
    ENTRADA = "Entrada"
    PLATO_FUERTE = "Plato Fuerte"
    BEBIDA = "Bebida"
    POSTRE = "Postre"


class EstadoPedido(Enum):
    """Estados del pedido"""
    PENDIENTE = "Pendiente"
    EN_PREPARACION = "En PreparaciÃ³n"
    LISTO = "Listo"
    ENTREGADO = "Entregado"
    CANCELADO = "Cancelado"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATRÃ“N FACTORY METHOD: CreaciÃ³n de Platos
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Plato(ABC):
    """
    ğŸ”¹ PATRÃ“N: Factory Method (Producto abstracto)

    Clase base para todos los platos
    """

    def __init__(self, nombre: str, precio: float, categoria: CategoriaPlato):
        self.nombre = nombre
        self.precio = precio
        self.categoria = categoria
        self.tiempo_preparacion = 10  # minutos

    @abstractmethod
    def preparar(self) -> str:
        """MÃ©todo abstracto de preparaciÃ³n"""
        pass

    def __repr__(self) -> str:
        return f"{self.nombre} (${self.precio:.2f})"


class Entrada(Plato):
    """Producto concreto: Entrada"""

    def preparar(self) -> str:
        return f"ğŸ¥— Preparando entrada: {self.nombre}"


class PlatoFuerte(Plato):
    """Producto concreto: Plato Fuerte"""

    def __init__(self, nombre: str, precio: float, tipo_carne: str = ""):
        super().__init__(nombre, precio, CategoriaPlato.PLATO_FUERTE)
        self.tipo_carne = tipo_carne
        self.tiempo_preparacion = 25

    def preparar(self) -> str:
        return f"ğŸ– Cocinando plato fuerte: {self.nombre} ({self.tipo_carne})"


class Bebida(Plato):
    """Producto concreto: Bebida"""

    def __init__(self, nombre: str, precio: float, tamaÃ±o: str = "mediana"):
        super().__init__(nombre, precio, CategoriaPlato.BEBIDA)
        self.tamaÃ±o = tamaÃ±o
        self.tiempo_preparacion = 2

    def preparar(self) -> str:
        return f"ğŸ¥¤ Sirviendo bebida: {self.nombre} ({self.tamaÃ±o})"


class Postre(Plato):
    """Producto concreto: Postre"""

    def preparar(self) -> str:
        return f"ğŸ° Preparando postre: {self.nombre}"


class FabricaPlatos:
    """
    ğŸ”¹ PATRÃ“N: Factory Method (Creator)

    Â¿Por quÃ©? Centraliza la creaciÃ³n de platos y permite
    registrar nuevos tipos dinÃ¡micamente.

    Beneficios:
    - Desacopla cÃ³digo cliente de clases concretas
    - FÃ¡cil agregar nuevos tipos
    - CatÃ¡logo centralizado
    """

    _catalogo = {
        # Entradas
        "ensalada_cesar": lambda: Entrada("Ensalada CÃ©sar", 85.00, CategoriaPlato.ENTRADA),
        "sopa_tortilla": lambda: Entrada("Sopa de Tortilla", 65.00, CategoriaPlato.ENTRADA),
        "guacamole": lambda: Entrada("Guacamole con Totopos", 75.00, CategoriaPlato.ENTRADA),

        # Platos Fuertes
        "arrachera": lambda: PlatoFuerte("Arrachera al carbÃ³n", 245.00, "res"),
        "salmon": lambda: PlatoFuerte("SalmÃ³n a la parrilla", 285.00, "pescado"),
        "pollo_parmesano": lambda: PlatoFuerte("Pollo Parmesano", 195.00, "pollo"),
        "tacos_pastor": lambda: PlatoFuerte("Tacos al Pastor (5 pzas)", 125.00, "cerdo"),

        # Bebidas
        "agua": lambda: Bebida("Agua Natural", 25.00, "mediana"),
        "refresco": lambda: Bebida("Refresco", 35.00, "mediana"),
        "cerveza": lambda: Bebida("Cerveza", 45.00, "330ml"),
        "limonada": lambda: Bebida("Limonada Natural", 40.00, "mediana"),

        # Postres
        "flan": lambda: Postre("Flan Napolitano", 55.00, CategoriaPlato.POSTRE),
        "pastel_chocolate": lambda: Postre("Pastel de Chocolate", 75.00, CategoriaPlato.POSTRE),
        "helado": lambda: Postre("Helado (2 bolas)", 45.00, CategoriaPlato.POSTRE),
    }

    @classmethod
    def crear_plato(cls, codigo: str) -> Optional[Plato]:
        """
        Crea un plato usando el catÃ¡logo

        Args:
            codigo: CÃ³digo del plato (ej: "arrachera", "ensalada_cesar")

        Returns:
            Instancia del plato o None si no existe
        """
        creador = cls._catalogo.get(codigo.lower())

        if not creador:
            print(f"âŒ Plato '{codigo}' no encontrado en catÃ¡logo")
            return None

        return creador()

    @classmethod
    def registrar_plato(cls, codigo: str, creador: Callable[[], Plato]):
        """Permite registrar nuevos platos dinÃ¡micamente"""
        cls._catalogo[codigo.lower()] = creador

    @classmethod
    def obtener_menu(cls) -> dict:
        """Retorna el menÃº organizado por categorÃ­as"""
        menu = {categoria: [] for categoria in CategoriaPlato}

        for codigo, creador in cls._catalogo.items():
            plato = creador()
            menu[plato.categoria].append((codigo, plato))

        return menu

    @classmethod
    def mostrar_menu(cls):
        """Imprime el menÃº completo"""
        menu = cls.obtener_menu()

        print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘                    MENÃš DEL RESTAURANTE                       â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

        for categoria in CategoriaPlato:
            if menu[categoria]:
                print(f"\n{'â•' * 63}")
                print(f"  {categoria.value.upper()}")
                print('â•' * 63)

                for codigo, plato in menu[categoria]:
                    print(f"  [{codigo:20s}] {plato.nombre:30s} ${plato.precio:>6.2f}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATRÃ“N DECORATOR: Extras para Platos
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DecoradorPlato(Plato):
    """
    ğŸ”¹ PATRÃ“N: Decorator

    Â¿Por quÃ©? Permite agregar extras a los platos sin
    modificar las clases existentes.

    Beneficios:
    - Extensible sin modificar cÃ³digo
    - ComposiciÃ³n flexible
    - Sigue OCP (Open/Closed Principle)
    """

    def __init__(self, plato: Plato):
        self._plato = plato
        # Copiamos atributos del plato decorado
        super().__init__(
            plato.nombre,
            plato.precio,
            plato.categoria
        )

    def preparar(self) -> str:
        return self._plato.preparar()


class ConQuesoDerretido(DecoradorPlato):
    """Agrega queso derretido al plato"""

    def __init__(self, plato: Plato):
        super().__init__(plato)
        self.nombre = f"{self._plato.nombre} + Queso derretido"
        self.precio = self._plato.precio + 25.00

    def preparar(self) -> str:
        return f"{self._plato.preparar()}\n      â””â”€ Agregando queso derretido ğŸ§€"


class ConGuacamoleExtra(DecoradorPlato):
    """Agrega guacamole extra"""

    def __init__(self, plato: Plato):
        super().__init__(plato)
        self.nombre = f"{self._plato.nombre} + Guacamole"
        self.precio = self._plato.precio + 35.00

    def preparar(self) -> str:
        return f"{self._plato.preparar()}\n      â””â”€ Agregando guacamole extra ğŸ¥‘"


class ConFrijoles(DecoradorPlato):
    """Agrega frijoles refritos"""

    def __init__(self, plato: Plato):
        super().__init__(plato)
        self.nombre = f"{self._plato.nombre} + Frijoles"
        self.precio = self._plato.precio + 20.00

    def preparar(self) -> str:
        return f"{self._plato.preparar()}\n      â””â”€ Agregando frijoles refritos"


class Picante(DecoradorPlato):
    """Hace el plato picante"""

    def __init__(self, plato: Plato):
        super().__init__(plato)
        self.nombre = f"{self._plato.nombre} (Picante ğŸŒ¶ï¸)"
        # No cuesta extra

    def preparar(self) -> str:
        return f"{self._plato.preparar()}\n      â””â”€ Â¡Preparando versiÃ³n PICANTE! ğŸ”¥"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATRÃ“N BUILDER: ConstrucciÃ³n de Pedidos
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Pedido:
    """Representa un pedido completo"""
    numero: str
    cliente: str
    items: List[Plato] = field(default_factory=list)
    estado: EstadoPedido = EstadoPedido.PENDIENTE
    notas: str = ""
    fecha_hora: datetime = field(default_factory=datetime.now)

    @property
    def subtotal(self) -> float:
        """Calcula subtotal"""
        return sum(item.precio for item in self.items)

    @property
    def total(self) -> float:
        """Calcula total con IVA"""
        config = ConfiguracionRestaurante()
        return config.calcular_total_con_iva(self.subtotal)

    @property
    def cantidad_items(self) -> int:
        """Cantidad de items"""
        return len(self.items)


class ConstructorPedido:
    """
    ğŸ”¹ PATRÃ“N: Builder

    Â¿Por quÃ©? Los pedidos son objetos complejos que se construyen
    paso a paso con validaciones.

    Beneficios:
    - ConstrucciÃ³n fluida (fluent interface)
    - Validaciones durante construcciÃ³n
    - CÃ³digo mÃ¡s legible
    - SeparaciÃ³n de construcciÃ³n y representaciÃ³n
    """

    def __init__(self, numero: str, cliente: str):
        self._pedido = Pedido(numero=numero, cliente=cliente)
        self._config = ConfiguracionRestaurante()

    def agregar_plato(self, codigo_plato: str) -> 'ConstructorPedido':
        """
        Agrega un plato al pedido

        Returns:
            self para encadenamiento
        """
        # Validar lÃ­mite
        if len(self._pedido.items) >= self._config.max_items_por_pedido:
            print(f"âŒ MÃ¡ximo {self._config.max_items_por_pedido} items por pedido")
            return self

        plato = FabricaPlatos.crear_plato(codigo_plato)

        if plato:
            self._pedido.items.append(plato)
            print(f"âœ“ Agregado: {plato.nombre}")

        return self

    def agregar_plato_personalizado(self, plato: Plato) -> 'ConstructorPedido':
        """
        Agrega un plato ya construido (posiblemente decorado)

        Returns:
            self para encadenamiento
        """
        if len(self._pedido.items) >= self._config.max_items_por_pedido:
            print(f"âŒ MÃ¡ximo {self._config.max_items_por_pedido} items por pedido")
            return self

        self._pedido.items.append(plato)
        print(f"âœ“ Agregado: {plato.nombre}")
        return self

    def con_notas(self, notas: str) -> 'ConstructorPedido':
        """
        Agrega notas especiales al pedido

        Returns:
            self para encadenamiento
        """
        self._pedido.notas = notas
        return self

    def construir(self) -> Pedido:
        """
        Construye y retorna el pedido final

        Returns:
            Pedido completo
        """
        if not self._pedido.items:
            raise ValueError("El pedido debe tener al menos un item")

        pedido = self._pedido
        # Reset para poder construir otro pedido
        self._pedido = Pedido(
            numero=f"{pedido.numero}",
            cliente=pedido.cliente
        )

        return pedido


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATRÃ“N STRATEGY: MÃ©todos de Pago
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MetodoPago(ABC):
    """
    ğŸ”¹ PATRÃ“N: Strategy (Estrategia abstracta)

    Â¿Por quÃ©? MÃºltiples mÃ©todos de pago con lÃ³gicas diferentes.

    Beneficios:
    - Algoritmos intercambiables
    - FÃ¡cil agregar nuevos mÃ©todos
    - CÃ³digo mÃ¡s limpio y mantenible
    """

    @abstractmethod
    def procesar_pago(self, monto: float) -> bool:
        """Procesa el pago con el mÃ©todo especÃ­fico"""
        pass

    @property
    @abstractmethod
    def nombre(self) -> str:
        """Nombre del mÃ©todo de pago"""
        pass


class PagoEfectivo(MetodoPago):
    """Estrategia: Pago en efectivo"""

    def procesar_pago(self, monto: float) -> bool:
        print(f"\nğŸ’µ Procesando pago en EFECTIVO")
        print(f"   Monto: ${monto:.2f}")
        print(f"   âœ“ Pago recibido en efectivo")
        return True

    @property
    def nombre(self) -> str:
        return "Efectivo"


class PagoTarjetaCredito(MetodoPago):
    """Estrategia: Tarjeta de crÃ©dito"""

    def __init__(self, numero_tarjeta: str):
        self.numero_tarjeta = numero_tarjeta

    def procesar_pago(self, monto: float) -> bool:
        # Simular validaciÃ³n
        ultimos_digitos = self.numero_tarjeta[-4:]

        print(f"\nğŸ’³ Procesando pago con TARJETA")
        print(f"   Tarjeta: **** **** **** {ultimos_digitos}")
        print(f"   Monto: ${monto:.2f}")
        print(f"   Conectando con banco...")
        print(f"   âœ“ Pago autorizado")

        return True

    @property
    def nombre(self) -> str:
        return "Tarjeta de CrÃ©dito"


class PagoTransferencia(MetodoPago):
    """Estrategia: Transferencia bancaria"""

    def __init__(self, banco: str, clabe: str):
        self.banco = banco
        self.clabe = clabe

    def procesar_pago(self, monto: float) -> bool:
        print(f"\nğŸ¦ Procesando TRANSFERENCIA")
        print(f"   Banco: {self.banco}")
        print(f"   CLABE: {self.clabe}")
        print(f"   Monto: ${monto:.2f}")
        print(f"   Esperando confirmaciÃ³n...")
        print(f"   âœ“ Transferencia confirmada")

        return True

    @property
    def nombre(self) -> str:
        return "Transferencia Bancaria"


class PagoCarteraDigital(MetodoPago):
    """Estrategia: Cartera digital (PayPal, etc.)"""

    def __init__(self, proveedor: str, email: str):
        self.proveedor = proveedor
        self.email = email

    def procesar_pago(self, monto: float) -> bool:
        print(f"\nğŸ“± Procesando pago con {self.proveedor.upper()}")
        print(f"   Cuenta: {self.email}")
        print(f"   Monto: ${monto:.2f}")
        print(f"   Conectando con {self.proveedor}...")
        print(f"   âœ“ Pago confirmado")

        return True

    @property
    def nombre(self) -> str:
        return f"Cartera Digital ({self.proveedor})"


class ProcesadorPagos:
    """
    ğŸ”¹ Contexto que usa las estrategias de pago
    """

    def __init__(self, metodo_pago: MetodoPago):
        self._metodo_pago = metodo_pago

    def cambiar_metodo(self, metodo_pago: MetodoPago):
        """Cambia el mÃ©todo de pago en tiempo de ejecuciÃ³n"""
        self._metodo_pago = metodo_pago

    def pagar(self, pedido: Pedido) -> bool:
        """Procesa el pago del pedido"""
        print(f"\n{'â•' * 63}")
        print(f"  PROCESANDO PAGO - Pedido #{pedido.numero}")
        print(f"{'â•' * 63}")
        print(f"Cliente: {pedido.cliente}")
        print(f"MÃ©todo de pago: {self._metodo_pago.nombre}")

        exito = self._metodo_pago.procesar_pago(pedido.total)

        if exito:
            print(f"\nâœ“ Pago completado exitosamente")
        else:
            print(f"\nâŒ Error al procesar pago")

        return exito


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATRÃ“N OBSERVER: Notificaciones de Estado
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ObservadorPedido(ABC):
    """
    ğŸ”¹ PATRÃ“N: Observer (Observador abstracto)

    Â¿Por quÃ©? MÃºltiples sistemas necesitan ser notificados
    cuando cambia el estado del pedido.

    Beneficios:
    - Desacoplamiento entre sujeto y observadores
    - FÃ¡cil agregar nuevos observadores
    - PatrÃ³n publicador-suscriptor
    """

    @abstractmethod
    def notificar_cambio_estado(self, pedido: Pedido, estado_anterior: EstadoPedido):
        """Notifica cambio de estado del pedido"""
        pass


class NotificadorCliente(ObservadorPedido):
    """Observador: Notifica al cliente"""

    def notificar_cambio_estado(self, pedido: Pedido, estado_anterior: EstadoPedido):
        print(f"\nğŸ“§ EMAIL a {pedido.cliente}:")
        print(f"   Su pedido #{pedido.numero} cambiÃ³ de estado")
        print(f"   {estado_anterior.value} â†’ {pedido.estado.value}")


class ActualizadorCocina(ObservadorPedido):
    """Observador: Actualiza pantalla de cocina"""

    def notificar_cambio_estado(self, pedido: Pedido, estado_anterior: EstadoPedido):
        if pedido.estado == EstadoPedido.EN_PREPARACION:
            print(f"\nğŸ‘¨â€ğŸ³ COCINA: Nuevo pedido #{pedido.numero} para preparar")
            print(f"   Items: {pedido.cantidad_items}")
        elif pedido.estado == EstadoPedido.LISTO:
            print(f"\nâœ“ COCINA: Pedido #{pedido.numero} LISTO para entregar")


class RegistroHistorial(ObservadorPedido):
    """Observador: Registra en historial/base de datos"""

    def __init__(self):
        self.historial: List[tuple] = []

    def notificar_cambio_estado(self, pedido: Pedido, estado_anterior: EstadoPedido):
        entrada = (
            datetime.now(),
            pedido.numero,
            estado_anterior.value,
            pedido.estado.value
        )
        self.historial.append(entrada)
        print(f"\nğŸ’¾ REGISTRO: Cambio guardado en base de datos")


class GestorPedidos:
    """
    ğŸ”¹ Sujeto Observable

    Gestiona pedidos y notifica a observadores
    """

    def __init__(self):
        self._observadores: List[ObservadorPedido] = []
        self._pedidos: dict[str, Pedido] = {}

    def agregar_observador(self, observador: ObservadorPedido):
        """Suscribe un observador"""
        if observador not in self._observadores:
            self._observadores.append(observador)
            print(f"âœ“ Observador agregado: {type(observador).__name__}")

    def eliminar_observador(self, observador: ObservadorPedido):
        """Desuscribe un observador"""
        self._observadores.remove(observador)

    def _notificar_observadores(self, pedido: Pedido, estado_anterior: EstadoPedido):
        """Notifica a todos los observadores"""
        for observador in self._observadores:
            observador.notificar_cambio_estado(pedido, estado_anterior)

    def registrar_pedido(self, pedido: Pedido):
        """Registra un nuevo pedido"""
        self._pedidos[pedido.numero] = pedido
        print(f"\nâœ“ Pedido #{pedido.numero} registrado")

    def cambiar_estado(self, numero_pedido: str, nuevo_estado: EstadoPedido):
        """Cambia el estado de un pedido y notifica"""
        pedido = self._pedidos.get(numero_pedido)

        if not pedido:
            print(f"âŒ Pedido #{numero_pedido} no encontrado")
            return

        estado_anterior = pedido.estado
        pedido.estado = nuevo_estado

        print(f"\nğŸ”„ Pedido #{numero_pedido}: {estado_anterior.value} â†’ {nuevo_estado.value}")

        # Notificar a todos los observadores
        self._notificar_observadores(pedido, estado_anterior)

    def obtener_pedido(self, numero_pedido: str) -> Optional[Pedido]:
        """Obtiene un pedido por nÃºmero"""
        return self._pedidos.get(numero_pedido)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SISTEMA PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SistemaRestaurante:
    """
    Fachada del sistema completo que integra todos los patrones
    """

    def __init__(self):
        self.config = ConfiguracionRestaurante()
        self.gestor_pedidos = GestorPedidos()
        self._contador_pedidos = 0

        # Configurar observadores por defecto
        self.gestor_pedidos.agregar_observador(NotificadorCliente())
        self.gestor_pedidos.agregar_observador(ActualizadorCocina())
        self.gestor_pedidos.agregar_observador(RegistroHistorial())

    def generar_numero_pedido(self) -> str:
        """Genera nÃºmero Ãºnico de pedido"""
        self._contador_pedidos += 1
        return f"PED-{datetime.now().strftime('%Y%m%d')}-{self._contador_pedidos:04d}"

    def mostrar_menu(self):
        """Muestra el menÃº"""
        FabricaPlatos.mostrar_menu()

    def crear_constructor_pedido(self, cliente: str) -> ConstructorPedido:
        """Crea un constructor de pedido"""
        numero = self.generar_numero_pedido()
        return ConstructorPedido(numero, cliente)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEMOSTRACIÃ“N COMPLETA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """DemostraciÃ³n del sistema completo con todos los patrones"""

    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘         SISTEMA DE RESTAURANTE - PATRONES DE DISEÃ‘O          â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. SINGLETON: ConfiguraciÃ³n Ãºnica
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n1ï¸âƒ£  PATRÃ“N SINGLETON - ConfiguraciÃ³n")
    print("â”€" * 63)

    config1 = ConfiguracionRestaurante()
    config2 = ConfiguracionRestaurante()
    print(f"Config 1: {config1.nombre_restaurante}")
    print(f"Config 2: {config2.nombre_restaurante}")
    print(f"Â¿Misma instancia? {config1 is config2} âœ“")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. FACTORY: Crear platos
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n2ï¸âƒ£  PATRÃ“N FACTORY METHOD - CreaciÃ³n de Platos")
    print("â”€" * 63)

    FabricaPlatos.mostrar_menu()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. DECORATOR: Personalizar platos
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n3ï¸âƒ£  PATRÃ“N DECORATOR - PersonalizaciÃ³n")
    print("â”€" * 63)

    # Plato base
    tacos = FabricaPlatos.crear_plato("tacos_pastor")
    print(f"\nPlato base: {tacos.nombre} - ${tacos.precio:.2f}")

    # Agregar decoradores
    tacos = ConQuesoDerretido(tacos)
    print(f"Con queso:  {tacos.nombre} - ${tacos.precio:.2f}")

    tacos = ConGuacamoleExtra(tacos)
    print(f"Con guacamole: {tacos.nombre} - ${tacos.precio:.2f}")

    tacos = Picante(tacos)
    print(f"Picante:    {tacos.nombre} - ${tacos.precio:.2f}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. BUILDER: Construir pedido complejo
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n4ï¸âƒ£  PATRÃ“N BUILDER - ConstrucciÃ³n de Pedido")
    print("â”€" * 63)

    sistema = SistemaRestaurante()

    # Crear pedido con fluent interface
    print("\nCreando pedido para Juan PÃ©rez...")

    builder = sistema.crear_constructor_pedido("Juan PÃ©rez")

    pedido1 = (builder
               .agregar_plato("ensalada_cesar")
               .agregar_plato("arrachera")
               .agregar_plato_personalizado(tacos)  # Plato decorado
               .agregar_plato("cerveza")
               .agregar_plato("flan")
               .con_notas("Sin cebolla por favor")
               .construir())

    print(f"\nâœ“ Pedido construido:")
    print(f"  NÃºmero: {pedido1.numero}")
    print(f"  Cliente: {pedido1.cliente}")
    print(f"  Items: {pedido1.cantidad_items}")
    print(f"  Subtotal: ${pedido1.subtotal:.2f}")
    print(f"  Total (con IVA): ${pedido1.total:.2f}")
    print(f"  Notas: {pedido1.notas}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. OBSERVER: Registro y notificaciones
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n5ï¸âƒ£  PATRÃ“N OBSERVER - Sistema de Notificaciones")
    print("â”€" * 63)

    # Registrar pedido
    sistema.gestor_pedidos.registrar_pedido(pedido1)

    # Cambios de estado (notifica automÃ¡ticamente)
    print("\n--- Pedido recibido, enviando a cocina ---")
    sistema.gestor_pedidos.cambiar_estado(
        pedido1.numero,
        EstadoPedido.EN_PREPARACION
    )

    print("\n--- Pedido preparado ---")
    sistema.gestor_pedidos.cambiar_estado(
        pedido1.numero,
        EstadoPedido.LISTO
    )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. STRATEGY: Procesar pago
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n6ï¸âƒ£  PATRÃ“N STRATEGY - MÃ©todos de Pago")
    print("â”€" * 63)

    # OpciÃ³n 1: Tarjeta
    print("\n>>> OpciÃ³n 1: Pagar con tarjeta")
    metodo_tarjeta = PagoTarjetaCredito("4532-1234-5678-9010")
    procesador = ProcesadorPagos(metodo_tarjeta)
    procesador.pagar(pedido1)

    # Crear otro pedido para mostrar otro mÃ©todo
    print("\n\n--- Nuevo pedido ---")
    builder2 = sistema.crear_constructor_pedido("MarÃ­a GonzÃ¡lez")
    pedido2 = (builder2
               .agregar_plato("salmon")
               .agregar_plato("agua")
               .construir())

    sistema.gestor_pedidos.registrar_pedido(pedido2)

    # OpciÃ³n 2: Efectivo
    print("\n>>> OpciÃ³n 2: Pagar en efectivo")
    metodo_efectivo = PagoEfectivo()
    procesador.cambiar_metodo(metodo_efectivo)
    procesador.pagar(pedido2)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # RESUMEN
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘                    RESUMEN DE PATRONES                        â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

    print("""
âœ… SINGLETON      - ConfiguraciÃ³n Ãºnica compartida
âœ… FACTORY METHOD - CreaciÃ³n flexible de platos
âœ… BUILDER        - ConstrucciÃ³n fluida de pedidos
âœ… DECORATOR      - PersonalizaciÃ³n de platos sin modificar clases
âœ… STRATEGY       - MÃºltiples mÃ©todos de pago intercambiables
âœ… OBSERVER       - Notificaciones automÃ¡ticas de cambios de estado

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Todos los patrones trabajan juntos en un sistema cohesivo,
cada uno resolviendo un problema especÃ­fico de diseÃ±o.
    """)

    print("\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


if __name__ == "__main__":
    main()
```

## ğŸ” AnÃ¡lisis de Cada PatrÃ³n

### 1. Singleton - ConfiguracionRestaurante

**Problema resuelto**: Necesitamos una configuraciÃ³n global Ãºnica
**ImplementaciÃ³n clave**:

- `__new__` controla la creaciÃ³n
- `_inicializada` previene reinicializaciÃ³n
- Acceso global controlado

### 2. Factory Method - FabricaPlatos

**Problema resuelto**: Crear platos sin acoplar a clases concretas
**ImplementaciÃ³n clave**:

- Diccionario de factories lambda
- MÃ©todo `crear_plato()` centralizado
- Registro dinÃ¡mico con `registrar_plato()`

### 3. Builder - ConstructorPedido

**Problema resuelto**: ConstrucciÃ³n compleja paso a paso
**ImplementaciÃ³n clave**:

- Fluent interface (retorna `self`)
- Validaciones durante construcciÃ³n
- MÃ©todo `construir()` final

### 4. Decorator - DecoradorPlato

**Problema resuelto**: Agregar extras sin modificar clases
**ImplementaciÃ³n clave**:

- ComposiciÃ³n en lugar de herencia
- Cadena de decoradores
- Preserva interfaz original

### 5. Strategy - MetodoPago

**Problema resuelto**: Algoritmos de pago intercambiables
**ImplementaciÃ³n clave**:

- Interfaz `MetodoPago` comÃºn
- Implementaciones especÃ­ficas
- Cambio en tiempo de ejecuciÃ³n

### 6. Observer - ObservadorPedido

**Problema resuelto**: Notificar mÃºltiples sistemas
**ImplementaciÃ³n clave**:

- Lista de observadores
- MÃ©todo `agregar_observador()`
- NotificaciÃ³n automÃ¡tica

## ğŸ“Š ComparaciÃ³n: Sin Patrones vs Con Patrones

| Aspecto               | Sin Patrones         | Con Patrones               |
| --------------------- | -------------------- | -------------------------- |
| **ConfiguraciÃ³n**     | MÃºltiples instancias | Una instancia (Singleton)  |
| **Crear platos**      | `if/elif` gigante    | Factory extensible         |
| **Construir pedidos** | Constructor complejo | Builder fluido             |
| **Personalizar**      | Herencia explosiva   | Decoradores componibles    |
| **Pagos**             | CÃ³digo duplicado     | Strategies intercambiables |
| **Notificaciones**    | Acoplamiento fuerte  | Observers desacoplados     |

## âœ… Puntos Clave para Replicar

### Singleton

1. Controlar `__new__` para instancia Ãºnica
2. Usar flag `_inicializada`
3. Garantizar thread-safety si es necesario

### Factory

1. Diccionario de factories
2. MÃ©todo `crear()` centralizado
3. Permitir registro dinÃ¡mico

### Builder

1. Fluent interface (retornar `self`)
2. Validar en cada paso
3. MÃ©todo `build()` final

### Decorator

1. Heredar de clase base
2. ComposiciÃ³n con instancia decorada
3. Delegar y agregar comportamiento

### Strategy

1. Interfaz abstracta comÃºn
2. Implementaciones concretas
3. Contexto que usa strategies

### Observer

1. Lista de observadores
2. MÃ©todos suscribir/desuscribir
3. Notificar a todos en eventos

## ğŸ“ Conceptos Aplicados

- âœ… 6 patrones de diseÃ±o clÃ¡sicos
- âœ… ABC para abstracciones
- âœ… Dataclasses
- âœ… Enumeraciones
- âœ… Type hints
- âœ… Fluent interface
- âœ… Composition over inheritance
- âœ… SOLID principles
- âœ… Separation of concerns

## ğŸš€ Ejercicios Adicionales

1. **Agregar patrÃ³n Command** para deshacer/rehacer pedidos
2. **Agregar patrÃ³n State** para ciclo de vida del pedido
3. **Agregar patrÃ³n Facade** para simplificar interfaz
4. **Agregar patrÃ³n Proxy** para cachÃ© de platos
5. **Agregar patrÃ³n Template Method** para proceso de preparaciÃ³n

## ğŸ“š Referencias

- "Design Patterns: Elements of Reusable Object-Oriented Software" - Gang of Four
- "Head First Design Patterns" - Freeman & Freeman
- [Refactoring Guru - Design Patterns](https://refactoring.guru/design-patterns)
- [Python Design Patterns](https://python-patterns.guide/)
