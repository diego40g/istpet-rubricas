# A6. RefactorizaciÃ³n Aplicando Principios SOLID

## ğŸ“‹ DescripciÃ³n de la Actividad

Esta actividad guÃ­a a travÃ©s de un proceso completo de **refactorizaciÃ³n** aplicando los **5 principios SOLID**. Se parte de un cÃ³digo con mÃºltiples violaciones y se transforma paso a paso en un diseÃ±o limpio, mantenible y extensible. Es una actividad prÃ¡ctica que demuestra cÃ³mo SOLID mejora significativamente la calidad del cÃ³digo.

## ğŸ¯ Objetivos de Aprendizaje

- Identificar violaciones de principios SOLID en cÃ³digo existente
- Aplicar cada principio SOLID de forma prÃ¡ctica
- Refactorizar cÃ³digo para cumplir con SOLID
- Entender los beneficios de aplicar SOLID
- Crear cÃ³digo mÃ¡s mantenible y extensible
- Aplicar inyecciÃ³n de dependencias

## ğŸ“ Los 5 Principios SOLID

### S - Single Responsibility Principle (SRP)

**"Una clase debe tener una Ãºnica razÃ³n para cambiar"**

- Cada clase debe tener una sola responsabilidad
- Facilita el mantenimiento y testing

### O - Open/Closed Principle (OCP)

**"Abierto a extensiÃ³n, cerrado a modificaciÃ³n"**

- Debe poder extenderse sin modificar cÃ³digo existente
- Usar abstracciones para permitir extensiones

### L - Liskov Substitution Principle (LSP)

**"Las subclases deben ser sustituibles por sus clases base"**

- Las clases derivadas no deben romper el contrato de la clase base
- Comportamiento consistente en jerarquÃ­as

### I - Interface Segregation Principle (ISP)

**"Interfaces especÃ­ficas mejor que interfaces generales"**

- No forzar a implementar mÃ©todos no necesarios
- Interfaces pequeÃ±as y cohesivas

### D - Dependency Inversion Principle (DIP)

**"Depender de abstracciones, no de implementaciones concretas"**

- MÃ³dulos de alto nivel no deben depender de mÃ³dulos de bajo nivel
- Ambos deben depender de abstracciones

## ğŸ’» SoluciÃ³n Completa

### Parte 1: CÃ³digo Original (CON VIOLACIONES)

```python
# sistema_biblioteca_malo.py
# âš ï¸ CÃ“DIGO CON MÃšLTIPLES VIOLACIONES SOLID

from datetime import datetime, timedelta
from typing import List

class Libro:
    """Clase Libro que hace DEMASIADAS cosas (Viola SRP)"""

    def __init__(self, isbn: str, titulo: str, autor: str, precio: float):
        self.isbn = isbn
        self.titulo = titulo
        self.autor = autor
        self.precio = precio
        self.prestado = False
        self.usuario_actual = None
        self.fecha_prestamo = None

    # RESPONSABILIDAD 1: GestiÃ³n del libro
    def prestar(self, usuario: str) -> bool:
        """Presta el libro"""
        if self.prestado:
            return False
        self.prestado = True
        self.usuario_actual = usuario
        self.fecha_prestamo = datetime.now()
        return True

    def devolver(self) -> bool:
        """Devuelve el libro"""
        if not self.prestado:
            return False
        self.prestado = False
        self.usuario_actual = None
        self.fecha_prestamo = None
        return True

    # RESPONSABILIDAD 2: CÃ¡lculo de multas (Â¡Viola SRP!)
    def calcular_multa(self) -> float:
        """Calcula multa por retraso"""
        if not self.prestado or not self.fecha_prestamo:
            return 0

        dias_prestado = (datetime.now() - self.fecha_prestamo).days
        dias_permitidos = 14

        if dias_prestado > dias_permitidos:
            dias_retraso = dias_prestado - dias_permitidos
            return dias_retraso * 2.0  # $2 por dÃ­a
        return 0

    # RESPONSABILIDAD 3: Persistencia (Â¡Viola SRP!)
    def guardar_en_archivo(self, archivo: str):
        """Guarda el libro en archivo"""
        with open(archivo, 'a') as f:
            f.write(f"{self.isbn},{self.titulo},{self.autor},{self.precio}\n")

    # RESPONSABILIDAD 4: Notificaciones (Â¡Viola SRP!)
    def notificar_devolucion(self):
        """Notifica sobre devoluciÃ³n"""
        if self.usuario_actual:
            # Hardcodeado para email (Â¡Viola OCP!)
            print(f"ğŸ“§ Email a {self.usuario_actual}: Devolver '{self.titulo}'")

    # RESPONSABILIDAD 5: GeneraciÃ³n de reportes (Â¡Viola SRP!)
    def generar_reporte(self) -> str:
        """Genera reporte del libro"""
        estado = "Prestado" if self.prestado else "Disponible"
        return f"Libro: {self.titulo}\nAutor: {self.autor}\nEstado: {estado}"


class Usuario:
    """Usuario que tambiÃ©n hace demasiado (Viola SRP)"""

    def __init__(self, id: str, nombre: str, email: str):
        self.id = id
        self.nombre = nombre
        self.email = email
        self.libros_prestados: List[Libro] = []

    # LÃ³gica de prÃ©stamo duplicada (Viola DRY)
    def prestar_libro(self, libro: Libro) -> bool:
        """Presta un libro al usuario"""
        if len(self.libros_prestados) >= 3:
            print("âŒ No puede tener mÃ¡s de 3 libros")
            return False

        if libro.prestar(self.nombre):
            self.libros_prestados.append(libro)
            # Email hardcodeado (Viola ISP y OCP)
            print(f"ğŸ“§ Email a {self.email}: Libro '{libro.titulo}' prestado")
            return True
        return False

    def devolver_libro(self, libro: Libro) -> bool:
        """Devuelve un libro"""
        if libro not in self.libros_prestados:
            return False

        multa = libro.calcular_multa()
        libro.devolver()
        self.libros_prestados.remove(libro)

        # Email hardcodeado (Viola OCP)
        if multa > 0:
            print(f"ğŸ“§ Email a {self.email}: Multa de ${multa:.2f}")

        return True


class Biblioteca:
    """
    Biblioteca que depende de implementaciones concretas (Viola DIP)
    y tiene responsabilidades mezcladas (Viola SRP)
    """

    def __init__(self):
        self.libros: List[Libro] = []
        self.usuarios: List[Usuario] = []
        # Hardcoded a archivo (Viola DIP)
        self.archivo_libros = "libros.txt"

    def agregar_libro(self, libro: Libro):
        """Agrega un libro"""
        self.libros.append(libro)
        # Persistencia mezclada con lÃ³gica (Viola SRP y DIP)
        libro.guardar_en_archivo(self.archivo_libros)

    def registrar_usuario(self, usuario: Usuario):
        """Registra un usuario"""
        self.usuarios.append(usuario)
        # Email hardcodeado (Viola OCP)
        print(f"ğŸ“§ Email a {usuario.email}: Bienvenido a la biblioteca")

    def buscar_libro(self, titulo: str) -> Libro:
        """Busca libro por tÃ­tulo"""
        for libro in self.libros:
            if titulo.lower() in libro.titulo.lower():
                return libro
        return None

    def listar_disponibles(self) -> List[Libro]:
        """Lista libros disponibles"""
        return [libro for libro in self.libros if not libro.prestado]

    # Genera reporte (Viola SRP - responsabilidad de reporting)
    def generar_reporte_general(self) -> str:
        """Genera reporte de la biblioteca"""
        reporte = "=== REPORTE DE BIBLIOTECA ===\n"
        reporte += f"Total libros: {len(self.libros)}\n"
        reporte += f"Disponibles: {len(self.listar_disponibles())}\n"
        reporte += f"Usuarios: {len(self.usuarios)}\n"
        return reporte


# PROBLEMAS IDENTIFICADOS:
# âŒ SRP: Libro tiene 5 responsabilidades diferentes
# âŒ OCP: Notificaciones hardcodeadas, no se pueden extender
# âŒ LSP: No aplicable en este ejemplo simple
# âŒ ISP: No hay interfaces, todo estÃ¡ acoplado
# âŒ DIP: Dependencias directas de implementaciones concretas
```

### Parte 2: CÃ³digo Refactorizado (APLICANDO SOLID)

```python
# sistema_biblioteca_solid.py
# âœ… CÃ“DIGO REFACTORIZADO APLICANDO SOLID

from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from typing import List, Optional, Protocol
from dataclasses import dataclass
from enum import Enum


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENTIDADES (SRP: Responsabilidad Ãºnica - Datos del dominio)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Libro:
    """
    âœ… SRP: Solo representa datos de un libro
    No tiene lÃ³gica de negocio, persistencia ni notificaciones
    """
    isbn: str
    titulo: str
    autor: str
    precio: float
    disponible: bool = True


@dataclass
class Usuario:
    """
    âœ… SRP: Solo representa datos de un usuario
    """
    id: str
    nombre: str
    email: str
    telefono: str = ""


@dataclass
class Prestamo:
    """
    âœ… SRP: Representa un prÃ©stamo
    Responsabilidad Ãºnica: mantener datos del prÃ©stamo
    """
    id: str
    libro_isbn: str
    usuario_id: str
    fecha_prestamo: datetime
    fecha_devolucion_esperada: datetime
    fecha_devolucion_real: Optional[datetime] = None
    multa: float = 0.0

    @property
    def esta_activo(self) -> bool:
        """Verifica si el prÃ©stamo estÃ¡ activo"""
        return self.fecha_devolucion_real is None

    @property
    def dias_prestado(self) -> int:
        """Calcula dÃ­as de prÃ©stamo"""
        if self.fecha_devolucion_real:
            return (self.fecha_devolucion_real - self.fecha_prestamo).days
        return (datetime.now() - self.fecha_prestamo).days


class EstadoPrestamo(Enum):
    """EnumeraciÃ³n de estados"""
    ACTIVO = "Activo"
    DEVUELTO = "Devuelto"
    VENCIDO = "Vencido"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTERFACES (ISP: Interfaces segregadas)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Repositorio(ABC):
    """
    âœ… ISP: Interface especÃ­fica para persistencia
    âœ… DIP: AbstracciÃ³n para que servicios dependan de ella
    """

    @abstractmethod
    def guardar(self, entidad: any) -> bool:
        """Guarda una entidad"""
        pass

    @abstractmethod
    def obtener(self, id: str) -> Optional[any]:
        """Obtiene una entidad por ID"""
        pass

    @abstractmethod
    def listar(self) -> List[any]:
        """Lista todas las entidades"""
        pass

    @abstractmethod
    def actualizar(self, entidad: any) -> bool:
        """Actualiza una entidad"""
        pass


class Notificador(ABC):
    """
    âœ… ISP: Interface especÃ­fica para notificaciones
    âœ… OCP: Abierta a extensiÃ³n con nuevos notificadores
    """

    @abstractmethod
    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """EnvÃ­a una notificaciÃ³n"""
        pass


class CalculadorMultas(ABC):
    """
    âœ… ISP: Interface especÃ­fica para cÃ¡lculo de multas
    âœ… OCP: Permite diferentes estrategias de multa
    """

    @abstractmethod
    def calcular(self, prestamo: Prestamo) -> float:
        """Calcula la multa de un prÃ©stamo"""
        pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IMPLEMENTACIONES DE REPOSITORIOS (DIP)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RepositorioMemoria(Repositorio):
    """
    âœ… DIP: ImplementaciÃ³n concreta del repositorio
    âœ… SRP: Solo se encarga de persistencia en memoria
    """

    def __init__(self):
        self._almacen = {}

    def guardar(self, entidad: any) -> bool:
        """Guarda en memoria"""
        id_entidad = self._obtener_id(entidad)
        self._almacen[id_entidad] = entidad
        return True

    def obtener(self, id: str) -> Optional[any]:
        """Obtiene de memoria"""
        return self._almacen.get(id)

    def listar(self) -> List[any]:
        """Lista todas las entidades"""
        return list(self._almacen.values())

    def actualizar(self, entidad: any) -> bool:
        """Actualiza en memoria"""
        id_entidad = self._obtener_id(entidad)
        if id_entidad in self._almacen:
            self._almacen[id_entidad] = entidad
            return True
        return False

    def _obtener_id(self, entidad: any) -> str:
        """Obtiene el ID de la entidad"""
        if isinstance(entidad, Libro):
            return entidad.isbn
        elif isinstance(entidad, Usuario):
            return entidad.id
        elif isinstance(entidad, Prestamo):
            return entidad.id
        raise ValueError(f"Tipo de entidad no soportado: {type(entidad)}")


class RepositorioArchivo(Repositorio):
    """
    âœ… OCP: Nueva implementaciÃ³n sin modificar cÃ³digo existente
    âœ… LSP: Puede sustituir a cualquier Repositorio
    """

    def __init__(self, archivo: str):
        self.archivo = archivo
        self._cache = {}
        self._cargar()

    def _cargar(self):
        """Carga datos del archivo"""
        try:
            with open(self.archivo, 'r') as f:
                # ImplementaciÃ³n simplificada
                pass
        except FileNotFoundError:
            pass

    def guardar(self, entidad: any) -> bool:
        """Guarda en archivo"""
        # ImplementaciÃ³n real guardarÃ­a en archivo
        id_entidad = self._obtener_id(entidad)
        self._cache[id_entidad] = entidad
        return True

    def obtener(self, id: str) -> Optional[any]:
        return self._cache.get(id)

    def listar(self) -> List[any]:
        return list(self._cache.values())

    def actualizar(self, entidad: any) -> bool:
        return self.guardar(entidad)

    def _obtener_id(self, entidad: any) -> str:
        if isinstance(entidad, Libro):
            return entidad.isbn
        elif isinstance(entidad, Usuario):
            return entidad.id
        elif isinstance(entidad, Prestamo):
            return entidad.id
        raise ValueError(f"Tipo de entidad no soportado")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# IMPLEMENTACIONES DE NOTIFICADORES (OCP)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NotificadorEmail(Notificador):
    """
    âœ… OCP: ImplementaciÃ³n especÃ­fica para email
    âœ… SRP: Solo se encarga de enviar emails
    """

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """EnvÃ­a email"""
        print(f"ğŸ“§ Email a {destinatario}")
        print(f"   Asunto: {asunto}")
        print(f"   Mensaje: {mensaje}")
        return True


class NotificadorSMS(Notificador):
    """
    âœ… OCP: Nueva implementaciÃ³n sin modificar cÃ³digo existente
    """

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """EnvÃ­a SMS"""
        print(f"ğŸ“± SMS a {destinatario}: {mensaje[:160]}")
        return True


class NotificadorWhatsApp(Notificador):
    """
    âœ… OCP: Otra implementaciÃ³n nueva
    """

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """EnvÃ­a WhatsApp"""
        print(f"ğŸ’¬ WhatsApp a {destinatario}: {mensaje}")
        return True


class NotificadorMultiple(Notificador):
    """
    âœ… Composite Pattern: Combina mÃºltiples notificadores
    """

    def __init__(self, notificadores: List[Notificador]):
        self._notificadores = notificadores

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """EnvÃ­a por todos los canales"""
        return all(n.enviar(destinatario, mensaje, asunto)
                  for n in self._notificadores)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CALCULADORES DE MULTAS (OCP)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CalculadorMultaEstandar(CalculadorMultas):
    """
    âœ… OCP: Estrategia estÃ¡ndar de multa
    âœ… SRP: Solo calcula multas
    """

    def __init__(self, dias_permitidos: int = 14, multa_por_dia: float = 2.0):
        self.dias_permitidos = dias_permitidos
        self.multa_por_dia = multa_por_dia

    def calcular(self, prestamo: Prestamo) -> float:
        """Calcula multa estÃ¡ndar"""
        if not prestamo.esta_activo:
            return prestamo.multa

        dias_retraso = prestamo.dias_prestado - self.dias_permitidos

        if dias_retraso > 0:
            return dias_retraso * self.multa_por_dia

        return 0.0


class CalculadorMultaProgresiva(CalculadorMultas):
    """
    âœ… OCP: Estrategia alternativa sin modificar cÃ³digo existente
    Multa aumenta progresivamente con los dÃ­as de retraso
    """

    def __init__(self, dias_permitidos: int = 14):
        self.dias_permitidos = dias_permitidos

    def calcular(self, prestamo: Prestamo) -> float:
        """Calcula multa progresiva"""
        if not prestamo.esta_activo:
            return prestamo.multa

        dias_retraso = prestamo.dias_prestado - self.dias_permitidos

        if dias_retraso <= 0:
            return 0.0

        # Multa progresiva: $2 primeros 7 dÃ­as, $5 despuÃ©s
        if dias_retraso <= 7:
            return dias_retraso * 2.0
        else:
            return (7 * 2.0) + ((dias_retraso - 7) * 5.0)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERVICIOS (SRP + DIP)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ServicioPrestamos:
    """
    âœ… SRP: Solo gestiona prÃ©stamos
    âœ… DIP: Depende de abstracciones (Repositorio, Notificador, CalculadorMultas)
    """

    def __init__(
        self,
        repo_libros: Repositorio,
        repo_usuarios: Repositorio,
        repo_prestamos: Repositorio,
        notificador: Notificador,
        calculador_multas: CalculadorMultas
    ):
        """
        âœ… DIP: InyecciÃ³n de dependencias
        Recibe abstracciones, no implementaciones concretas
        """
        self._repo_libros = repo_libros
        self._repo_usuarios = repo_usuarios
        self._repo_prestamos = repo_prestamos
        self._notificador = notificador
        self._calculador_multas = calculador_multas

    def crear_prestamo(self, libro_isbn: str, usuario_id: str) -> Optional[Prestamo]:
        """
        Crea un nuevo prÃ©stamo.
        âœ… SRP: Solo lÃ³gica de prÃ©stamo
        """
        # Obtener libro y usuario
        libro = self._repo_libros.obtener(libro_isbn)
        usuario = self._repo_usuarios.obtener(usuario_id)

        if not libro or not usuario:
            print("âŒ Libro o usuario no encontrado")
            return None

        if not libro.disponible:
            print("âŒ Libro no disponible")
            return None

        # Verificar lÃ­mite de prÃ©stamos
        prestamos_activos = self._obtener_prestamos_activos_usuario(usuario_id)
        if len(prestamos_activos) >= 3:
            print("âŒ Usuario tiene 3 libros prestados (mÃ¡ximo)")
            return None

        # Crear prÃ©stamo
        prestamo = Prestamo(
            id=f"PREST-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            libro_isbn=libro_isbn,
            usuario_id=usuario_id,
            fecha_prestamo=datetime.now(),
            fecha_devolucion_esperada=datetime.now() + timedelta(days=14)
        )

        # Actualizar disponibilidad
        libro.disponible = False
        self._repo_libros.actualizar(libro)

        # Guardar prÃ©stamo
        self._repo_prestamos.guardar(prestamo)

        # Notificar
        self._notificador.enviar(
            usuario.email,
            f"Has prestado '{libro.titulo}'. Devolver antes del "
            f"{prestamo.fecha_devolucion_esperada.strftime('%d/%m/%Y')}",
            "PrÃ©stamo de Libro"
        )

        print(f"âœ“ PrÃ©stamo creado: {prestamo.id}")

        return prestamo

    def devolver_prestamo(self, prestamo_id: str) -> bool:
        """
        Procesa la devoluciÃ³n de un libro.
        âœ… SRP: Solo lÃ³gica de devoluciÃ³n
        """
        prestamo = self._repo_prestamos.obtener(prestamo_id)

        if not prestamo or not prestamo.esta_activo:
            print("âŒ PrÃ©stamo no encontrado o ya devuelto")
            return False

        # Calcular multa
        multa = self._calculador_multas.calcular(prestamo)
        prestamo.multa = multa
        prestamo.fecha_devolucion_real = datetime.now()

        # Actualizar disponibilidad del libro
        libro = self._repo_libros.obtener(prestamo.libro_isbn)
        libro.disponible = True
        self._repo_libros.actualizar(libro)

        # Actualizar prÃ©stamo
        self._repo_prestamos.actualizar(prestamo)

        # Notificar
        usuario = self._repo_usuarios.obtener(prestamo.usuario_id)
        mensaje = f"Libro '{libro.titulo}' devuelto."

        if multa > 0:
            mensaje += f" Multa: ${multa:.2f}"

        self._notificador.enviar(usuario.email, mensaje, "DevoluciÃ³n de Libro")

        print(f"âœ“ Libro devuelto. Multa: ${multa:.2f}")

        return True

    def _obtener_prestamos_activos_usuario(self, usuario_id: str) -> List[Prestamo]:
        """Obtiene prÃ©stamos activos de un usuario"""
        todos = self._repo_prestamos.listar()
        return [p for p in todos
                if p.usuario_id == usuario_id and p.esta_activo]

    def listar_prestamos_vencidos(self) -> List[Prestamo]:
        """
        Lista prÃ©stamos vencidos.
        âœ… SRP: Consulta especÃ­fica
        """
        todos = self._repo_prestamos.listar()
        ahora = datetime.now()

        return [p for p in todos
                if p.esta_activo and p.fecha_devolucion_esperada < ahora]


class ServicioReportes:
    """
    âœ… SRP: Solo genera reportes
    âœ… DIP: Depende de abstracciones
    """

    def __init__(
        self,
        repo_libros: Repositorio,
        repo_usuarios: Repositorio,
        repo_prestamos: Repositorio
    ):
        self._repo_libros = repo_libros
        self._repo_usuarios = repo_usuarios
        self._repo_prestamos = repo_prestamos

    def generar_reporte_general(self) -> str:
        """Genera reporte general de la biblioteca"""
        libros = self._repo_libros.listar()
        usuarios = self._repo_usuarios.listar()
        prestamos = self._repo_prestamos.listar()

        disponibles = [l for l in libros if l.disponible]
        prestamos_activos = [p for p in prestamos if p.esta_activo]

        reporte = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              REPORTE GENERAL DE BIBLIOTECA                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LIBROS:
  Total:        {len(libros)}
  Disponibles:  {len(disponibles)}
  Prestados:    {len(libros) - len(disponibles)}

USUARIOS:
  Total:        {len(usuarios)}

PRÃ‰STAMOS:
  Activos:      {len(prestamos_activos)}
  HistÃ³ricos:   {len(prestamos)}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        return reporte

    def generar_reporte_usuario(self, usuario_id: str) -> str:
        """Genera reporte de un usuario especÃ­fico"""
        usuario = self._repo_usuarios.obtener(usuario_id)

        if not usuario:
            return "Usuario no encontrado"

        prestamos = self._repo_prestamos.listar()
        prestamos_usuario = [p for p in prestamos if p.usuario_id == usuario_id]
        activos = [p for p in prestamos_usuario if p.esta_activo]

        reporte = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              REPORTE DE USUARIO                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATOS:
  ID:       {usuario.id}
  Nombre:   {usuario.nombre}
  Email:    {usuario.email}

PRÃ‰STAMOS:
  Activos:      {len(activos)}
  HistÃ³ricos:   {len(prestamos_usuario)}

LIBROS ACTUALES:
"""

        for prestamo in activos:
            libro = self._repo_libros.obtener(prestamo.libro_isbn)
            reporte += f"  â€¢ {libro.titulo}\n"
            reporte += f"    Devolver: {prestamo.fecha_devolucion_esperada.strftime('%d/%m/%Y')}\n"

        reporte += "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"

        return reporte


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FACHADA (Facade Pattern)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SistemaBiblioteca:
    """
    âœ… Facade: Interfaz simplificada del sistema completo
    âœ… DIP: Configura e inyecta todas las dependencias
    """

    def __init__(self):
        """Configura el sistema con todas sus dependencias"""
        # Repositorios
        self.repo_libros = RepositorioMemoria()
        self.repo_usuarios = RepositorioMemoria()
        self.repo_prestamos = RepositorioMemoria()

        # Notificador
        self.notificador = NotificadorMultiple([
            NotificadorEmail(),
            NotificadorSMS()
        ])

        # Calculador de multas
        self.calculador_multas = CalculadorMultaEstandar()

        # Servicios
        self.servicio_prestamos = ServicioPrestamos(
            self.repo_libros,
            self.repo_usuarios,
            self.repo_prestamos,
            self.notificador,
            self.calculador_multas
        )

        self.servicio_reportes = ServicioReportes(
            self.repo_libros,
            self.repo_usuarios,
            self.repo_prestamos
        )

    def configurar_notificador(self, notificador: Notificador):
        """Permite cambiar el notificador (âœ… OCP)"""
        self.notificador = notificador
        self.servicio_prestamos = ServicioPrestamos(
            self.repo_libros,
            self.repo_usuarios,
            self.repo_prestamos,
            notificador,
            self.calculador_multas
        )

    def configurar_calculador_multas(self, calculador: CalculadorMultas):
        """Permite cambiar el calculador de multas (âœ… OCP)"""
        self.calculador_multas = calculador
        self.servicio_prestamos = ServicioPrestamos(
            self.repo_libros,
            self.repo_usuarios,
            self.repo_prestamos,
            self.notificador,
            calculador
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEMOSTRACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """DemostraciÃ³n del sistema refactorizado con SOLID"""

    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘       SISTEMA DE BIBLIOTECA (APLICANDO SOLID)                â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    # Crear sistema
    sistema = SistemaBiblioteca()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. AGREGAR DATOS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("1. AGREGANDO LIBROS Y USUARIOS")
    print("â”€" * 63)

    # Libros
    libros = [
        Libro("978-0-13-468599-1", "Clean Code", "Robert C. Martin", 45.99),
        Libro("978-0-13-235088-4", "Clean Architecture", "Robert C. Martin", 42.99),
        Libro("978-0-13-468599-2", "Design Patterns", "Gang of Four", 54.99),
    ]

    for libro in libros:
        sistema.repo_libros.guardar(libro)
        print(f"âœ“ Libro agregado: {libro.titulo}")

    # Usuarios
    usuarios = [
        Usuario("U001", "Juan PÃ©rez", "juan@email.com", "555-1234"),
        Usuario("U002", "MarÃ­a GonzÃ¡lez", "maria@email.com", "555-5678"),
    ]

    for usuario in usuarios:
        sistema.repo_usuarios.guardar(usuario)
        print(f"âœ“ Usuario registrado: {usuario.nombre}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. CREAR PRÃ‰STAMOS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n2. CREANDO PRÃ‰STAMOS")
    print("â”€" * 63)

    prestamo1 = sistema.servicio_prestamos.crear_prestamo(
        libros[0].isbn,
        usuarios[0].id
    )

    prestamo2 = sistema.servicio_prestamos.crear_prestamo(
        libros[1].isbn,
        usuarios[0].id
    )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. CAMBIAR ESTRATEGIA DE MULTA (OCP EN ACCIÃ“N)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n3. CAMBIANDO ESTRATEGIA DE MULTA (OCP)")
    print("â”€" * 63)

    print("Configurando calculador de multa progresiva...")
    sistema.configurar_calculador_multas(CalculadorMultaProgresiva())
    print("âœ“ Estrategia cambiada sin modificar cÃ³digo existente")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. DEVOLVER LIBRO
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n4. DEVOLVIENDO LIBRO")
    print("â”€" * 63)

    if prestamo1:
        sistema.servicio_prestamos.devolver_prestamo(prestamo1.id)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. GENERAR REPORTES
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n5. REPORTES")
    print("â”€" * 63)

    print(sistema.servicio_reportes.generar_reporte_general())
    print(sistema.servicio_reportes.generar_reporte_usuario(usuarios[0].id))

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. CAMBIAR NOTIFICADOR (OCP EN ACCIÃ“N)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n6. CAMBIANDO SISTEMA DE NOTIFICACIONES (OCP)")
    print("â”€" * 63)

    print("Configurando solo WhatsApp...")
    sistema.configurar_notificador(NotificadorWhatsApp())
    print("âœ“ Notificador cambiado sin modificar cÃ³digo existente")

    # Crear otro prÃ©stamo con nuevo notificador
    print("\nCreando prÃ©stamo con nuevo notificador:")
    sistema.servicio_prestamos.crear_prestamo(
        libros[2].isbn,
        usuarios[1].id
    )

    print("\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


if __name__ == "__main__":
    main()
```

## ğŸ” AnÃ¡lisis Comparativo

### Antes de SOLID (Violaciones):

âŒ **SRP**: `Libro` tenÃ­a 5 responsabilidades
âŒ **OCP**: Notificaciones hardcodeadas
âŒ **ISP**: Sin interfaces, acoplamiento total
âŒ **DIP**: Dependencias directas de implementaciones

### DespuÃ©s de SOLID (Aplicado):

âœ… **SRP**: Cada clase tiene una responsabilidad

- `Libro`: Solo datos del libro
- `ServicioPrestamos`: Solo lÃ³gica de prÃ©stamos
- `ServicioReportes`: Solo generaciÃ³n de reportes
- `RepositorioMemoria`: Solo persistencia

âœ… **OCP**: Extensible sin modificar

- Nuevos notificadores sin cambiar cÃ³digo
- Nuevas estrategias de multa sin modificar servicios
- Nuevos repositorios sin afectar lÃ³gica

âœ… **LSP**: Sustituciones vÃ¡lidas

- Cualquier `Repositorio` puede sustituirse
- Cualquier `Notificador` funciona igual
- Cualquier `CalculadorMultas` es intercambiable

âœ… **ISP**: Interfaces segregadas

- `Repositorio`: Solo mÃ©todos de persistencia
- `Notificador`: Solo mÃ©todos de notificaciÃ³n
- `CalculadorMultas`: Solo cÃ¡lculo de multas

âœ… **DIP**: Dependencias invertidas

- Servicios dependen de abstracciones
- InyecciÃ³n de dependencias en constructores
- FÃ¡cil cambiar implementaciones

## ğŸ“Š Beneficios Obtenidos

| Aspecto            | Sin SOLID                  | Con SOLID                   |
| ------------------ | -------------------------- | --------------------------- |
| **Mantenibilidad** | DifÃ­cil modificar          | FÃ¡cil modificar             |
| **Testing**        | Acoplado, difÃ­cil testear  | Desacoplado, fÃ¡cil testear  |
| **Extensibilidad** | Requiere modificar cÃ³digo  | Solo agregar nuevas clases  |
| **Legibilidad**    | Clases grandes y complejas | Clases pequeÃ±as y enfocadas |
| **ReutilizaciÃ³n**  | CÃ³digo duplicado           | Componentes reutilizables   |
| **Flexibilidad**   | RÃ­gido y frÃ¡gil            | Flexible y robusto          |

## âœ… Puntos Clave para Replicar

1. **SRP**: Una clase, una responsabilidad
2. **OCP**: Usa abstracciones para extensiÃ³n
3. **LSP**: Subclases consistentes con clase base
4. **ISP**: Interfaces pequeÃ±as y especÃ­ficas
5. **DIP**: InyecciÃ³n de dependencias
6. **Abstracciones**: ABC para contratos
7. **ComposiciÃ³n**: Favor sobre herencia
8. **Testing**: CÃ³digo desacoplado es testeable

## ğŸ“ Conceptos Aplicados

- âœ… Principios SOLID completos
- âœ… InyecciÃ³n de dependencias
- âœ… Interfaces con ABC
- âœ… PatrÃ³n Strategy
- âœ… PatrÃ³n Facade
- âœ… PatrÃ³n Composite
- âœ… Dataclasses
- âœ… Enumeraciones
- âœ… Type hints
- âœ… SeparaciÃ³n de responsabilidades

## ğŸš€ Ejercicio Adicional

**Tarea**: Extender el sistema con:

1. âœ¨ Nuevo notificador (Telegram)
2. âœ¨ Nueva estrategia de multa (por categorÃ­a de libro)
3. âœ¨ Nuevo repositorio (Base de datos SQLite)
4. âœ¨ Sistema de reservas de libros
5. âœ¨ Historial de lecturas por usuario

**RestricciÃ³n**: âš ï¸ No modificar cÃ³digo existente, solo extender

Esto demostrarÃ¡ que has entendido correctamente el principio Open/Closed.

## ğŸ“š Referencias

- "Clean Code" - Robert C. Martin
- "Clean Architecture" - Robert C. Martin
- "Design Patterns" - Gang of Four
- [SOLID Principles in Python](https://realpython.com/solid-principles-python/)
