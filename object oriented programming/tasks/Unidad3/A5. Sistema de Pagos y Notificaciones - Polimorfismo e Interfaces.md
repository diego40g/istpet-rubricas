# A5. Sistema de Pagos y Notificaciones - Polimorfismo e Interfaces

## üìã Descripci√≥n de la Actividad

Esta actividad implementa un sistema completo de procesamiento de pagos y notificaciones que demuestra el poder del **polimorfismo** y las **interfaces** en Python. El sistema puede procesar diferentes m√©todos de pago y enviar notificaciones por m√∫ltiples canales, todo de forma polim√≥rfica y extensible.

## üéØ Objetivos de Aprendizaje

- Implementar interfaces con `ABC` (Abstract Base Classes)
- Aplicar polimorfismo para tratar diferentes tipos uniformemente
- Usar `Protocol` para duck typing estructurado
- Implementar el patr√≥n Strategy
- Crear sistemas extensibles sin modificar c√≥digo existente
- Aplicar el principio Open/Closed (abierto a extensi√≥n, cerrado a modificaci√≥n)

## üìù Requerimientos

### Sistema de Pagos (usando ABC):

**Interface `MetodoPago`**

- M√©todos abstractos: `procesar_pago()`, `validar()`, `obtener_info_segura()`
- Implementaciones: `TarjetaCredito`, `PayPal`, `Efectivo`, `Transferencia`, `Criptomoneda`

**Clase `ProcesadorPagos`**

- Procesa cualquier m√©todo de pago polim√≥rficamente
- Mantiene historial de transacciones
- Genera estad√≠sticas

### Sistema de Notificaciones (usando Protocol):

**Protocol `Notificador`**

- M√©todos: `enviar()`, `es_disponible()`
- Implementaciones: `Email`, `SMS`, `Push`, `WhatsApp`, `Slack`

**Clase `GestorNotificaciones`**

- Env√≠a notificaciones por m√∫ltiples canales
- Sistema de fallback
- Registro de intentos

## üíª Soluci√≥n Completa

```python
# sistema_pagos_notificaciones.py

from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Dict, Optional, Protocol, runtime_checkable
from dataclasses import dataclass, field
from enum import Enum
import hashlib
import re


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ENUMERACIONES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class EstadoPago(Enum):
    """Estados posibles de un pago"""
    PENDIENTE = "Pendiente"
    PROCESANDO = "Procesando"
    EXITOSO = "Exitoso"
    FALLIDO = "Fallido"
    CANCELADO = "Cancelado"
    REEMBOLSADO = "Reembolsado"


class CanalNotificacion(Enum):
    """Canales de notificaci√≥n disponibles"""
    EMAIL = "Email"
    SMS = "SMS"
    PUSH = "Push"
    WHATSAPP = "WhatsApp"
    SLACK = "Slack"


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PARTE 1: SISTEMA DE PAGOS CON ABC (POLIMORFISMO)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class ResultadoPago:
    """Resultado del procesamiento de un pago"""
    exito: bool
    referencia: str = ""
    metodo: str = ""
    monto: float = 0.0
    estado: EstadoPago = EstadoPago.PENDIENTE
    fecha: datetime = field(default_factory=datetime.now)
    error: str = ""
    datos_adicionales: Dict = field(default_factory=dict)

    def __str__(self) -> str:
        if self.exito:
            return f"‚úì Pago exitoso: ${self.monto:,.2f} - Ref: {self.referencia}"
        return f"‚úó Pago fallido: {self.error}"


class MetodoPago(ABC):
    """
    Interface abstracta para m√©todos de pago.
    Todos los m√©todos de pago deben implementar estos m√©todos.
    """

    @abstractmethod
    def procesar_pago(self, monto: float, descripcion: str = "") -> ResultadoPago:
        """
        Procesa un pago y retorna el resultado.

        Args:
            monto (float): Monto a pagar
            descripcion (str): Descripci√≥n del pago

        Returns:
            ResultadoPago: Resultado del procesamiento
        """
        pass

    @abstractmethod
    def validar(self) -> tuple[bool, str]:
        """
        Valida que el m√©todo de pago sea v√°lido.

        Returns:
            tuple[bool, str]: (es_valido, mensaje_error)
        """
        pass

    @abstractmethod
    def obtener_info_segura(self) -> str:
        """
        Retorna informaci√≥n censurada del m√©todo de pago.

        Returns:
            str: Informaci√≥n segura para mostrar
        """
        pass

    def generar_recibo(self, resultado: ResultadoPago) -> str:
        """
        M√©todo concreto compartido por todos los m√©todos de pago.
        Genera un recibo formateado.

        Args:
            resultado (ResultadoPago): Resultado del pago

        Returns:
            str: Recibo formateado
        """
        if not resultado.exito:
            return f"No se puede generar recibo: {resultado.error}"

        recibo = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     RECIBO DE PAGO                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

  Fecha:         {resultado.fecha.strftime('%d/%m/%Y %H:%M:%S')}
  Referencia:    {resultado.referencia}

  M√©todo:        {resultado.metodo}
  Informaci√≥n:   {self.obtener_info_segura()}

  Monto:         ${resultado.monto:,.2f}
  Estado:        {resultado.estado.value}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        return recibo

    @staticmethod
    def generar_referencia(prefijo: str) -> str:
        """Genera una referencia √∫nica para el pago"""
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        return f"{prefijo}-{timestamp}"


class TarjetaCredito(MetodoPago):
    """Implementaci√≥n de pago con tarjeta de cr√©dito"""

    def __init__(self, numero: str, titular: str, cvv: str, vencimiento: str):
        """
        Inicializa una tarjeta de cr√©dito.

        Args:
            numero (str): N√∫mero de tarjeta (16 d√≠gitos)
            titular (str): Nombre del titular
            cvv (str): C√≥digo de seguridad (3-4 d√≠gitos)
            vencimiento (str): Fecha de vencimiento (MM/YY)
        """
        self.numero = numero.replace(" ", "")
        self.titular = titular
        self._cvv = cvv  # Privado por seguridad
        self.vencimiento = vencimiento

    def validar(self) -> tuple[bool, str]:
        """Valida la tarjeta de cr√©dito"""
        # Validar n√∫mero (16 d√≠gitos)
        if not self.numero.isdigit() or len(self.numero) != 16:
            return False, "N√∫mero de tarjeta inv√°lido (debe tener 16 d√≠gitos)"

        # Validar CVV (3 o 4 d√≠gitos)
        if not self._cvv.isdigit() or len(self._cvv) not in [3, 4]:
            return False, "CVV inv√°lido"

        # Validar formato de vencimiento (MM/YY)
        if not re.match(r'^\d{2}/\d{2}$', self.vencimiento):
            return False, "Formato de vencimiento inv√°lido (use MM/YY)"

        # Validar que no est√© vencida
        mes, a√±o = map(int, self.vencimiento.split('/'))
        hoy = datetime.now()
        a√±o_completo = 2000 + a√±o

        if a√±o_completo < hoy.year or (a√±o_completo == hoy.year and mes < hoy.month):
            return False, "Tarjeta vencida"

        # Algoritmo de Luhn para validar n√∫mero de tarjeta
        if not self._validar_luhn():
            return False, "N√∫mero de tarjeta inv√°lido (verificaci√≥n Luhn)"

        return True, ""

    def _validar_luhn(self) -> bool:
        """Valida el n√∫mero de tarjeta con el algoritmo de Luhn"""
        digitos = [int(d) for d in self.numero]

        # Duplicar cada segundo d√≠gito de derecha a izquierda
        for i in range(len(digitos) - 2, -1, -2):
            digitos[i] *= 2
            if digitos[i] > 9:
                digitos[i] -= 9

        return sum(digitos) % 10 == 0

    def procesar_pago(self, monto: float, descripcion: str = "") -> ResultadoPago:
        """Procesa el pago con tarjeta de cr√©dito"""
        # Validar tarjeta
        es_valida, mensaje_error = self.validar()
        if not es_valida:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=mensaje_error
            )

        # Validar monto
        if monto <= 0:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error="El monto debe ser positivo"
            )

        # Simular procesamiento (en producci√≥n ser√≠a API de banco)
        referencia = self.generar_referencia("TC")

        return ResultadoPago(
            exito=True,
            referencia=referencia,
            metodo="Tarjeta de Cr√©dito",
            monto=monto,
            estado=EstadoPago.EXITOSO,
            datos_adicionales={
                "titular": self.titular,
                "ultimos_digitos": self.numero[-4:],
                "tipo_tarjeta": self._identificar_tipo_tarjeta()
            }
        )

    def _identificar_tipo_tarjeta(self) -> str:
        """Identifica el tipo de tarjeta por el n√∫mero"""
        primer_digito = self.numero[0]

        if primer_digito == '4':
            return "Visa"
        elif primer_digito == '5':
            return "MasterCard"
        elif primer_digito == '3':
            return "American Express"
        return "Desconocida"

    def obtener_info_segura(self) -> str:
        """Retorna informaci√≥n censurada de la tarjeta"""
        tipo = self._identificar_tipo_tarjeta()
        return f"{tipo} **** **** **** {self.numero[-4:]}"


class PayPal(MetodoPago):
    """Implementaci√≥n de pago con PayPal"""

    def __init__(self, email: str):
        """
        Inicializa una cuenta de PayPal.

        Args:
            email (str): Email de la cuenta PayPal
        """
        self.email = email
        self._autenticado = False
        self._saldo = 1000.0  # Simular saldo disponible

    def autenticar(self, password: str) -> bool:
        """
        Autentica la cuenta de PayPal.

        Args:
            password (str): Contrase√±a

        Returns:
            bool: True si la autenticaci√≥n fue exitosa
        """
        # Simulaci√≥n simple (en producci√≥n ser√≠a OAuth)
        if len(password) >= 8:
            self._autenticado = True
            print(f"‚úì PayPal autenticado: {self.email}")
            return True

        print(f"‚úó Autenticaci√≥n fallida")
        return False

    def validar(self) -> tuple[bool, str]:
        """Valida la cuenta de PayPal"""
        # Validar email
        patron_email = r'^[\w\.-]+@[\w\.-]+\.\w+$'
        if not re.match(patron_email, self.email):
            return False, "Email inv√°lido"

        # Verificar autenticaci√≥n
        if not self._autenticado:
            return False, "Cuenta no autenticada"

        return True, ""

    def procesar_pago(self, monto: float, descripcion: str = "") -> ResultadoPago:
        """Procesa el pago con PayPal"""
        # Validar cuenta
        es_valida, mensaje_error = self.validar()
        if not es_valida:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=mensaje_error
            )

        # Verificar saldo
        if monto > self._saldo:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=f"Saldo insuficiente. Disponible: ${self._saldo:,.2f}"
            )

        # Procesar pago
        self._saldo -= monto
        referencia = self.generar_referencia("PP")

        return ResultadoPago(
            exito=True,
            referencia=referencia,
            metodo="PayPal",
            monto=monto,
            estado=EstadoPago.EXITOSO,
            datos_adicionales={
                "email": self.email,
                "saldo_restante": self._saldo
            }
        )

    def obtener_info_segura(self) -> str:
        """Retorna informaci√≥n censurada del email"""
        partes = self.email.split("@")
        nombre_censurado = partes[0][:2] + "*" * (len(partes[0]) - 2)
        return f"{nombre_censurado}@{partes[1]}"


class Efectivo(MetodoPago):
    """Implementaci√≥n de pago en efectivo"""

    def __init__(self, monto_entregado: float):
        """
        Inicializa pago en efectivo.

        Args:
            monto_entregado (float): Monto que entrega el cliente
        """
        self.monto_entregado = monto_entregado
        self.cambio = 0.0

    def validar(self) -> tuple[bool, str]:
        """Valida el efectivo"""
        if self.monto_entregado <= 0:
            return False, "Monto entregado debe ser positivo"
        return True, ""

    def procesar_pago(self, monto: float, descripcion: str = "") -> ResultadoPago:
        """Procesa el pago en efectivo"""
        # Validar
        es_valido, mensaje_error = self.validar()
        if not es_valido:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=mensaje_error
            )

        # Verificar que el monto entregado sea suficiente
        if self.monto_entregado < monto:
            faltante = monto - self.monto_entregado
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=f"Monto insuficiente. Faltan ${faltante:,.2f}"
            )

        # Calcular cambio
        self.cambio = self.monto_entregado - monto
        referencia = self.generar_referencia("EF")

        return ResultadoPago(
            exito=True,
            referencia=referencia,
            metodo="Efectivo",
            monto=monto,
            estado=EstadoPago.EXITOSO,
            datos_adicionales={
                "monto_entregado": self.monto_entregado,
                "cambio": self.cambio
            }
        )

    def obtener_info_segura(self) -> str:
        """Retorna informaci√≥n del efectivo"""
        return f"Efectivo: ${self.monto_entregado:,.2f}"


class Transferencia(MetodoPago):
    """Implementaci√≥n de transferencia bancaria"""

    def __init__(self, banco_origen: str, cuenta_origen: str, clabe: str = ""):
        """
        Inicializa transferencia bancaria.

        Args:
            banco_origen (str): Nombre del banco
            cuenta_origen (str): N√∫mero de cuenta
            clabe (str, optional): CLABE interbancaria
        """
        self.banco_origen = banco_origen
        self.cuenta_origen = cuenta_origen
        self.clabe = clabe

    def validar(self) -> tuple[bool, str]:
        """Valida la transferencia"""
        # Validar cuenta (m√≠nimo 10 d√≠gitos)
        if not self.cuenta_origen.isdigit() or len(self.cuenta_origen) < 10:
            return False, "N√∫mero de cuenta inv√°lido"

        # Si hay CLABE, validar que tenga 18 d√≠gitos
        if self.clabe and (not self.clabe.isdigit() or len(self.clabe) != 18):
            return False, "CLABE inv√°lida (debe tener 18 d√≠gitos)"

        return True, ""

    def procesar_pago(self, monto: float, descripcion: str = "") -> ResultadoPago:
        """Procesa la transferencia"""
        # Validar
        es_valida, mensaje_error = self.validar()
        if not es_valida:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=mensaje_error
            )

        # Procesar (en producci√≥n ser√≠a SPEI o similar)
        referencia = self.generar_referencia("TB")

        return ResultadoPago(
            exito=True,
            referencia=referencia,
            metodo="Transferencia Bancaria",
            monto=monto,
            estado=EstadoPago.EXITOSO,
            datos_adicionales={
                "banco": self.banco_origen,
                "cuenta": self.cuenta_origen[-4:]
            }
        )

    def obtener_info_segura(self) -> str:
        """Retorna informaci√≥n censurada de la cuenta"""
        return f"{self.banco_origen}: ****{self.cuenta_origen[-4:]}"


class Criptomoneda(MetodoPago):
    """Implementaci√≥n de pago con criptomonedas"""

    def __init__(self, wallet_address: str, moneda: str = "BTC"):
        """
        Inicializa pago con criptomoneda.

        Args:
            wallet_address (str): Direcci√≥n de la wallet
            moneda (str): Tipo de criptomoneda (BTC, ETH, etc.)
        """
        self.wallet_address = wallet_address
        self.moneda = moneda.upper()
        self._tasa_cambio = {"BTC": 45000, "ETH": 3000, "USDT": 1}  # Simulado

    def validar(self) -> tuple[bool, str]:
        """Valida la wallet"""
        if len(self.wallet_address) < 26:
            return False, "Direcci√≥n de wallet inv√°lida"

        if self.moneda not in self._tasa_cambio:
            return False, f"Criptomoneda no soportada: {self.moneda}"

        return True, ""

    def procesar_pago(self, monto: float, descripcion: str = "") -> ResultadoPago:
        """Procesa el pago con criptomoneda"""
        # Validar
        es_valida, mensaje_error = self.validar()
        if not es_valida:
            return ResultadoPago(
                exito=False,
                estado=EstadoPago.FALLIDO,
                error=mensaje_error
            )

        # Convertir a criptomoneda
        monto_cripto = monto / self._tasa_cambio[self.moneda]

        # Generar hash de transacci√≥n (simulado)
        hash_transaccion = hashlib.sha256(
            f"{self.wallet_address}{monto}{datetime.now()}".encode()
        ).hexdigest()[:16]

        referencia = f"CRYPTO-{hash_transaccion}"

        return ResultadoPago(
            exito=True,
            referencia=referencia,
            metodo=f"Criptomoneda ({self.moneda})",
            monto=monto,
            estado=EstadoPago.EXITOSO,
            datos_adicionales={
                "moneda": self.moneda,
                "monto_cripto": f"{monto_cripto:.8f} {self.moneda}",
                "wallet": self.wallet_address[:8] + "..." + self.wallet_address[-8:],
                "hash_transaccion": hash_transaccion
            }
        )

    def obtener_info_segura(self) -> str:
        """Retorna informaci√≥n censurada de la wallet"""
        return f"{self.moneda}: {self.wallet_address[:8]}...{self.wallet_address[-8:]}"


class ProcesadorPagos:
    """
    Procesa pagos de forma polim√≥rfica.
    No necesita saber el tipo espec√≠fico de cada m√©todo de pago.
    """

    def __init__(self):
        """Inicializa el procesador de pagos"""
        self._historial: List[ResultadoPago] = []
        self._total_procesado = 0.0
        self._total_fallidos = 0

    def procesar(self, metodo: MetodoPago, monto: float,
                descripcion: str = "") -> ResultadoPago:
        """
        Procesa un pago con cualquier m√©todo de pago.
        POLIMORFISMO: Funciona con cualquier clase que implemente MetodoPago.

        Args:
            metodo (MetodoPago): M√©todo de pago a usar
            monto (float): Monto a pagar
            descripcion (str): Descripci√≥n del pago

        Returns:
            ResultadoPago: Resultado del procesamiento
        """
        print(f"\nüí≥ Procesando pago de ${monto:,.2f}...")
        print(f"   M√©todo: {metodo.obtener_info_segura()}")

        # POLIMORFISMO: llamamos a procesar_pago sin saber el tipo espec√≠fico
        resultado = metodo.procesar_pago(monto, descripcion)

        # Registrar resultado
        self._historial.append(resultado)

        if resultado.exito:
            self._total_procesado += monto
            print(resultado)
            print(metodo.generar_recibo(resultado))
        else:
            self._total_fallidos += 1
            print(resultado)

        return resultado

    def obtener_estadisticas(self) -> Dict:
        """Genera estad√≠sticas de los pagos procesados"""
        por_metodo = {}

        for resultado in self._historial:
            metodo = resultado.metodo
            if metodo not in por_metodo:
                por_metodo[metodo] = {
                    "cantidad": 0,
                    "total": 0.0,
                    "exitosos": 0,
                    "fallidos": 0
                }

            por_metodo[metodo]["cantidad"] += 1
            if resultado.exito:
                por_metodo[metodo]["total"] += resultado.monto
                por_metodo[metodo]["exitosos"] += 1
            else:
                por_metodo[metodo]["fallidos"] += 1

        return {
            "total_procesado": self._total_procesado,
            "total_transacciones": len(self._historial),
            "total_exitosos": len([r for r in self._historial if r.exito]),
            "total_fallidos": self._total_fallidos,
            "por_metodo": por_metodo
        }

    def generar_reporte(self) -> str:
        """Genera un reporte completo"""
        stats = self.obtener_estadisticas()

        reporte = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              REPORTE DE PROCESAMIENTO DE PAGOS               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

RESUMEN GENERAL:
  Total procesado:       ${stats['total_procesado']:,.2f}
  Transacciones totales: {stats['total_transacciones']}
  Exitosas:              {stats['total_exitosos']} ‚úì
  Fallidas:              {stats['total_fallidos']} ‚úó
  Tasa de √©xito:         {(stats['total_exitosos']/stats['total_transacciones']*100) if stats['total_transacciones'] > 0 else 0:.1f}%

DESGLOSE POR M√âTODO:
{'‚îÄ'*62}
"""

        for metodo, datos in stats['por_metodo'].items():
            reporte += f"""
  {metodo}:
    Transacciones: {datos['cantidad']}
    Total:         ${datos['total']:,.2f}
    Exitosas:      {datos['exitosos']} ‚úì
    Fallidas:      {datos['fallidos']} ‚úó
"""

        reporte += "\n" + "‚ïê" * 62 + "\n"

        return reporte


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PARTE 2: SISTEMA DE NOTIFICACIONES CON PROTOCOL (DUCK TYPING)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@runtime_checkable
class Notificador(Protocol):
    """
    Protocol para notificadores.
    Permite duck typing estructurado: si tiene estos m√©todos, es un Notificador.
    """

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """Env√≠a una notificaci√≥n"""
        ...

    def es_disponible(self) -> bool:
        """Verifica si el notificador est√° disponible"""
        ...


class Email:
    """Notificador por correo electr√≥nico"""

    def __init__(self, servidor_smtp: str = "smtp.example.com"):
        self.servidor_smtp = servidor_smtp
        self._disponible = True

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """Env√≠a un email"""
        if not self.es_disponible():
            return False

        # Validar email
        if "@" not in destinatario:
            print(f"‚úó Email inv√°lido: {destinatario}")
            return False

        # Simular env√≠o
        print(f"üìß Email enviado a {destinatario}")
        print(f"   Asunto: {asunto}")
        print(f"   Mensaje: {mensaje[:50]}...")
        return True

    def es_disponible(self) -> bool:
        return self._disponible


class SMS:
    """Notificador por SMS"""

    def __init__(self, proveedor: str = "Twilio"):
        self.proveedor = proveedor
        self._creditos = 100  # Simular cr√©ditos disponibles

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """Env√≠a un SMS"""
        if not self.es_disponible():
            print(f"‚úó Sin cr√©ditos para SMS")
            return False

        # Validar n√∫mero
        numero_limpio = destinatario.replace("-", "").replace(" ", "")
        if not numero_limpio.isdigit() or len(numero_limpio) < 10:
            print(f"‚úó N√∫mero de tel√©fono inv√°lido: {destinatario}")
            return False

        # Simular env√≠o
        self._creditos -= 1
        print(f"üì± SMS enviado a {destinatario}")
        print(f"   Mensaje: {mensaje[:50]}...")
        print(f"   Cr√©ditos restantes: {self._creditos}")
        return True

    def es_disponible(self) -> bool:
        return self._creditos > 0


class PushNotification:
    """Notificador por push notifications"""

    def __init__(self, servicio: str = "Firebase"):
        self.servicio = servicio
        self._activo = True

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """Env√≠a una push notification"""
        if not self.es_disponible():
            return False

        # destinatario ser√≠a el device_token en producci√≥n
        print(f"üîî Push enviada al dispositivo {destinatario[:8]}...")
        print(f"   T√≠tulo: {asunto}")
        print(f"   Cuerpo: {mensaje[:50]}...")
        return True

    def es_disponible(self) -> bool:
        return self._activo


class WhatsApp:
    """Notificador por WhatsApp"""

    def __init__(self, api_key: str = ""):
        self.api_key = api_key
        self._conectado = bool(api_key)

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """Env√≠a un mensaje por WhatsApp"""
        if not self.es_disponible():
            print(f"‚úó WhatsApp no est√° conectado")
            return False

        # Simular env√≠o
        print(f"üí¨ WhatsApp enviado a {destinatario}")
        print(f"   Mensaje: {mensaje[:50]}...")
        return True

    def es_disponible(self) -> bool:
        return self._conectado


class Slack:
    """Notificador por Slack"""

    def __init__(self, webhook_url: str = ""):
        self.webhook_url = webhook_url
        self._configurado = bool(webhook_url)

    def enviar(self, destinatario: str, mensaje: str, asunto: str = "") -> bool:
        """Env√≠a un mensaje a Slack"""
        if not self.es_disponible():
            print(f"‚úó Slack no est√° configurado")
            return False

        # destinatario ser√≠a el canal (#general, etc.)
        print(f"üíº Slack enviado a {destinatario}")
        print(f"   Mensaje: {mensaje}")
        return True

    def es_disponible(self) -> bool:
        return self._configurado


@dataclass
class ConfiguracionNotificacion:
    """Configuraci√≥n de prioridad de notificaciones"""
    canales_prioritarios: List[Notificador]
    canales_fallback: List[Notificador]
    reintentos: int = 3


class GestorNotificaciones:
    """
    Gestiona el env√≠o de notificaciones por m√∫ltiples canales.
    USA POLIMORFISMO: No necesita saber el tipo espec√≠fico de notificador.
    """

    def __init__(self):
        """Inicializa el gestor de notificaciones"""
        self._notificadores: List[Notificador] = []
        self._intentos: List[Dict] = []

    def registrar_notificador(self, notificador: Notificador):
        """
        Registra un notificador.
        Acepta cualquier objeto que implemente el Protocol Notificador.
        """
        # Verificar que implementa el Protocol
        if isinstance(notificador, Notificador):
            self._notificadores.append(notificador)
            print(f"‚úì Notificador registrado: {notificador.__class__.__name__}")
        else:
            print(f"‚úó El objeto no implementa el Protocol Notificador")

    def enviar_notificacion(self, destinatario: str, mensaje: str,
                           asunto: str = "", config: Optional[ConfiguracionNotificacion] = None):
        """
        Env√≠a una notificaci√≥n usando los canales registrados.

        Args:
            destinatario (str): Destinatario de la notificaci√≥n
            mensaje (str): Mensaje a enviar
            asunto (str): Asunto/t√≠tulo
            config (ConfiguracionNotificacion, optional): Configuraci√≥n personalizada
        """
        print(f"\nüì¢ Enviando notificaci√≥n...")

        canales = config.canales_prioritarios if config else self._notificadores

        # Intentar enviar por canales prioritarios
        for notificador in canales:
            intento = {
                "canal": notificador.__class__.__name__,
                "destinatario": destinatario,
                "mensaje": mensaje,
                "fecha": datetime.now(),
                "exitoso": False
            }

            if notificador.enviar(destinatario, mensaje, asunto):
                intento["exitoso"] = True
                self._intentos.append(intento)
                return True

            self._intentos.append(intento)

        # Si fall√≥, intentar con fallback
        if config and config.canales_fallback:
            print("\n‚ö†Ô∏è  Canales prioritarios fallaron, usando fallback...")

            for notificador in config.canales_fallback:
                if notificador.enviar(destinatario, mensaje, asunto):
                    return True

        print("‚úó No se pudo enviar la notificaci√≥n por ning√∫n canal")
        return False

    def enviar_multiple(self, destinatarios: List[tuple], mensaje: str, asunto: str = ""):
        """
        Env√≠a notificaci√≥n a m√∫ltiples destinatarios.

        Args:
            destinatarios (List[tuple]): Lista de (destinatario, notificador)
            mensaje (str): Mensaje a enviar
            asunto (str): Asunto
        """
        exitosos = 0
        for destinatario, notificador in destinatarios:
            if notificador.enviar(destinatario, mensaje, asunto):
                exitosos += 1

        print(f"\n‚úì Notificaciones enviadas: {exitosos}/{len(destinatarios)}")

    def obtener_reporte_intentos(self) -> str:
        """Genera un reporte de intentos de notificaci√≥n"""
        exitosos = len([i for i in self._intentos if i["exitoso"]])
        fallidos = len(self._intentos) - exitosos

        reporte = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            REPORTE DE NOTIFICACIONES                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

RESUMEN:
  Intentos totales:  {len(self._intentos)}
  Exitosos:          {exitosos} ‚úì
  Fallidos:          {fallidos} ‚úó
  Tasa de √©xito:     {(exitosos/len(self._intentos)*100) if self._intentos else 0:.1f}%

DESGLOSE POR CANAL:
{'‚îÄ'*62}
"""

        # Agrupar por canal
        por_canal = {}
        for intento in self._intentos:
            canal = intento["canal"]
            if canal not in por_canal:
                por_canal[canal] = {"total": 0, "exitosos": 0}
            por_canal[canal]["total"] += 1
            if intento["exitoso"]:
                por_canal[canal]["exitosos"] += 1

        for canal, datos in por_canal.items():
            tasa = (datos["exitosos"] / datos["total"] * 100) if datos["total"] > 0 else 0
            reporte += f"\n  {canal}:"
            reporte += f"\n    Total:    {datos['total']}"
            reporte += f"\n    Exitosos: {datos['exitosos']} ({tasa:.1f}%)\n"

        reporte += "\n" + "‚ïê" * 62 + "\n"

        return reporte


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# DEMOSTRACI√ìN COMPLETA
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def main():
    """Demostraci√≥n completa del sistema"""

    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë     SISTEMA DE PAGOS Y NOTIFICACIONES POLIM√ìRFICO            ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # PARTE 1: SISTEMA DE PAGOS
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    print("\n\n" + "‚ïê" * 62)
    print("PARTE 1: SISTEMA DE PAGOS (Polimorfismo con ABC)")
    print("‚ïê" * 62)

    procesador = ProcesadorPagos()

    # Crear diferentes m√©todos de pago
    tarjeta = TarjetaCredito("4532123456789012", "Juan P√©rez", "123", "12/25")

    paypal = PayPal("usuario@email.com")
    paypal.autenticar("password123")

    efectivo = Efectivo(1000)

    transferencia = Transferencia("BBVA", "1234567890", "123456789012345678")

    cripto = Criptomoneda("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa", "BTC")

    # Procesar pagos polim√≥rficamente
    print("\n\n1. PROCESANDO PAGOS CON DIFERENTES M√âTODOS")
    print("‚îÄ" * 62)

    pagos = [
        (tarjeta, 299.99, "Compra de laptop"),
        (paypal, 150.00, "Suscripci√≥n mensual"),
        (efectivo, 75.50, "Compra en tienda"),
        (transferencia, 500.00, "Pago de servicio"),
        (cripto, 1200.00, "Compra internacional")
    ]

    for metodo, monto, descripcion in pagos:
        procesador.procesar(metodo, monto, descripcion)

    # Generar reporte
    print("\n\n2. REPORTE DE PAGOS")
    print("‚îÄ" * 62)
    print(procesador.generar_reporte())

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # PARTE 2: SISTEMA DE NOTIFICACIONES
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    print("\n\n" + "‚ïê" * 62)
    print("PARTE 2: SISTEMA DE NOTIFICACIONES (Polimorfismo con Protocol)")
    print("‚ïê" * 62)

    gestor = GestorNotificaciones()

    # Crear notificadores
    email = Email()
    sms = SMS()
    push = PushNotification()
    whatsapp = WhatsApp("api_key_123")
    slack = Slack("https://hooks.slack.com/...")

    # Registrar notificadores
    print("\n\n3. REGISTRANDO NOTIFICADORES")
    print("‚îÄ" * 62)

    for notificador in [email, sms, push, whatsapp, slack]:
        gestor.registrar_notificador(notificador)

    # Enviar notificaciones de pagos
    print("\n\n4. ENVIANDO NOTIFICACIONES DE PAGOS")
    print("‚îÄ" * 62)

    # Configurar canales por prioridad
    config = ConfiguracionNotificacion(
        canales_prioritarios=[email, sms],
        canales_fallback=[push, whatsapp]
    )

    gestor.enviar_notificacion(
        "cliente@email.com",
        "Su pago de $299.99 ha sido procesado exitosamente",
        "Confirmaci√≥n de Pago",
        config
    )

    gestor.enviar_notificacion(
        "555-1234-5678",
        "Pago de $150.00 recibido. Gracias por su compra",
        "Pago Recibido"
    )

    # Enviar a m√∫ltiples destinatarios
    print("\n\n5. NOTIFICACIONES M√öLTIPLES")
    print("‚îÄ" * 62)

    destinatarios = [
        ("admin@tienda.com", email),
        ("555-9999-0000", sms),
        ("#ventas", slack)
    ]

    gestor.enviar_multiple(
        destinatarios,
        "Se han procesado 5 pagos por un total de $2,225.49",
        "Resumen de Ventas"
    )

    # Reporte de notificaciones
    print("\n\n6. REPORTE DE NOTIFICACIONES")
    print("‚îÄ" * 62)
    print(gestor.obtener_reporte_intentos())

    print("\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")


if __name__ == "__main__":
    main()
```

## üîç Explicaci√≥n Detallada

### Polimorfismo con ABC

```python
class MetodoPago(ABC):
    @abstractmethod
    def procesar_pago(self, monto: float) -> ResultadoPago:
        pass

class ProcesadorPagos:
    def procesar(self, metodo: MetodoPago, monto: float):
        # POLIMORFISMO: funciona con cualquier MetodoPago
        resultado = metodo.procesar_pago(monto)
```

**Ventajas:**

- ‚úÖ C√≥digo cliente no depende de implementaciones concretas
- ‚úÖ F√°cil agregar nuevos m√©todos de pago
- ‚úÖ Garantiza que todas las implementaciones tengan los m√©todos necesarios

### Duck Typing con Protocol

```python
@runtime_checkable
class Notificador(Protocol):
    def enviar(self, destinatario: str, mensaje: str) -> bool:
        ...

class Email:  # No hereda de Notificador!
    def enviar(self, destinatario: str, mensaje: str) -> bool:
        return True

# Funciona porque tiene los m√©todos necesarios
gestor.registrar_notificador(Email())  # ‚úì OK
```

**Ventajas:**

- ‚úÖ Mayor flexibilidad (no requiere herencia)
- ‚úÖ M√°s "pythonic"
- ‚úÖ Permite adaptar clases existentes sin modificarlas

## ‚úÖ Puntos Clave para Replicar

1. **ABC para contratos estrictos**: Cuando necesitas garantizar que las subclases implementen m√©todos espec√≠ficos
2. **Protocol para duck typing**: Cuando quieres flexibilidad sin herencia
3. **Polimorfismo**: Tratar objetos diferentes de forma uniforme
4. **M√©todos abstractos y concretos**: Combinar comportamiento com√∫n y espec√≠fico
5. **Validaciones**: Implementar en cada clase concreta
6. **Dataclasses**: Para objetos de datos simples
7. **Type hints**: Documentar interfaces esperadas
8. **Enums**: Para conjuntos fijos de valores

## üéì Conceptos Aplicados

- ‚úÖ Polimorfismo por subtipo (herencia)
- ‚úÖ Interfaces con ABC
- ‚úÖ M√©todos abstractos
- ‚úÖ Duck typing con Protocol
- ‚úÖ Runtime type checking
- ‚úÖ Patr√≥n Strategy
- ‚úÖ Dataclasses
- ‚úÖ Enumeraciones
- ‚úÖ Type hints avanzados
- ‚úÖ Principio Open/Closed

## üöÄ Extensiones Posibles

1. Integrar con APIs reales de pago (Stripe, PayPal)
2. Sistema de webhooks para confirmaciones
3. Soporte para pagos recurrentes
4. Sistema de reembolsos
5. Autenticaci√≥n 2FA
6. Logs de auditor√≠a
7. Dashboard de m√©tricas
8. Integraci√≥n con contabilidad
9. Soporte multimoneda
10. Detecci√≥n de fraude
