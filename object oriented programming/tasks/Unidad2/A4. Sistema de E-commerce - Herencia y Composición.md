# A4. Sistema de E-commerce - Herencia y ComposiciÃ³n

## ğŸ“‹ DescripciÃ³n de la Actividad

Esta actividad implementa un sistema completo de comercio electrÃ³nico que combina **herencia** y **composiciÃ³n** de manera prÃ¡ctica. El sistema demuestra cuÃ¡ndo usar cada enfoque y cÃ³mo integrarlos efectivamente para crear una arquitectura flexible y mantenible.

## ğŸ¯ Objetivos de Aprendizaje

- Aplicar herencia para modelar jerarquÃ­as de clases relacionadas
- Usar composiciÃ³n para crear relaciones "tiene un"
- Diferenciar cuÃ¡ndo usar herencia vs composiciÃ³n
- Implementar el principio "favor composition over inheritance"
- Utilizar `super()` correctamente
- Crear clases abstractas con `ABC`

## ğŸ“ Requerimientos

### USANDO HERENCIA (relaciÃ³n "es un"):

**Clase base `Producto`**

- Clases derivadas: `ProductoFisico`, `ProductoDigital`, `Servicio`
- Cada tipo tiene caracterÃ­sticas y mÃ©todos especÃ­ficos

### USANDO COMPOSICIÃ“N (relaciÃ³n "tiene un"):

**Clase `Carrito`**

- Tiene lista de `ItemCarrito`

**Clase `Pedido`**

- Tiene `DireccionEnvio`
- Tiene `MetodoPago`
- Tiene `Carrito`

**Clase `Cliente`**

- Tiene lista de `Direcciones`
- Tiene lista de `MetodosPago`
- Tiene `HistorialPedidos`

## ğŸ’» SoluciÃ³n Completa

```python
# ecommerce.py

from abc import ABC, abstractmethod
from datetime import datetime, date
from typing import List, Optional, Dict
from enum import Enum
from dataclasses import dataclass
import uuid


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENUMERACIONES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class EstadoPedido(Enum):
    """Estados posibles de un pedido"""
    PENDIENTE = "Pendiente"
    PAGADO = "Pagado"
    ENVIADO = "Enviado"
    ENTREGADO = "Entregado"
    CANCELADO = "Cancelado"


class TipoProducto(Enum):
    """Tipos de productos"""
    FISICO = "FÃ­sico"
    DIGITAL = "Digital"
    SERVICIO = "Servicio"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARTE 1: HERENCIA - JERARQUÃA DE PRODUCTOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Producto(ABC):
    """
    Clase base abstracta para todos los productos.
    RelaciÃ³n de HERENCIA: "ProductoFisico ES UN Producto"
    """

    _contador = 0

    def __init__(self, nombre: str, descripcion: str, precio: float,
                 stock_disponible: int = 0):
        """
        Inicializa un producto base.

        Args:
            nombre (str): Nombre del producto
            descripcion (str): DescripciÃ³n detallada
            precio (float): Precio unitario
            stock_disponible (int): Cantidad en stock
        """
        Producto._contador += 1
        self.id = f"PROD-{Producto._contador:06d}"
        self.nombre = nombre
        self.descripcion = descripcion
        self.precio = precio
        self.stock_disponible = stock_disponible
        self.fecha_creacion = datetime.now()
        self._activo = True

    @abstractmethod
    def calcular_costo_total(self, cantidad: int) -> float:
        """
        MÃ©todo abstracto: cada tipo de producto calcula su costo diferente.

        Args:
            cantidad (int): Cantidad a calcular

        Returns:
            float: Costo total
        """
        pass

    @abstractmethod
    def puede_ser_enviado(self) -> bool:
        """Indica si el producto requiere envÃ­o fÃ­sico"""
        pass

    @abstractmethod
    def obtener_tipo(self) -> TipoProducto:
        """Retorna el tipo de producto"""
        pass

    def verificar_disponibilidad(self, cantidad: int) -> bool:
        """
        Verifica si hay stock suficiente.

        Args:
            cantidad (int): Cantidad solicitada

        Returns:
            bool: True si hay stock suficiente
        """
        return self.stock_disponible >= cantidad

    def reducir_stock(self, cantidad: int):
        """Reduce el stock del producto"""
        if not self.verificar_disponibilidad(cantidad):
            raise ValueError(f"Stock insuficiente para {self.nombre}")
        self.stock_disponible -= cantidad

    def aumentar_stock(self, cantidad: int):
        """Aumenta el stock del producto"""
        self.stock_disponible += cantidad

    def __str__(self) -> str:
        return f"{self.nombre} - ${self.precio:,.2f}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}('{self.nombre}', {self.precio})"


class ProductoFisico(Producto):
    """
    Producto fÃ­sico que requiere envÃ­o.
    Hereda de Producto y agrega atributos especÃ­ficos de productos tangibles.
    """

    def __init__(self, nombre: str, descripcion: str, precio: float,
                 peso_kg: float, dimensiones: tuple, stock_disponible: int = 0):
        """
        Inicializa un producto fÃ­sico.

        Args:
            nombre (str): Nombre del producto
            descripcion (str): DescripciÃ³n
            precio (float): Precio
            peso_kg (float): Peso en kilogramos
            dimensiones (tuple): (largo, ancho, alto) en cm
            stock_disponible (int): Stock inicial
        """
        super().__init__(nombre, descripcion, precio, stock_disponible)
        self.peso_kg = peso_kg
        self.dimensiones = dimensiones  # (largo, ancho, alto)

    def calcular_costo_total(self, cantidad: int) -> float:
        """
        Calcula costo total incluyendo el precio base.

        Args:
            cantidad (int): Cantidad de productos

        Returns:
            float: Precio * cantidad
        """
        return self.precio * cantidad

    def calcular_costo_envio(self, destino_cp: str) -> float:
        """
        Calcula el costo de envÃ­o basado en peso y dimensiones.

        Args:
            destino_cp (str): CÃ³digo postal de destino

        Returns:
            float: Costo de envÃ­o
        """
        # FÃ³rmula simplificada: $50 base + $10 por kg
        costo_base = 50
        costo_por_kg = 10

        # Calcular volumen (mÂ³)
        volumen_m3 = (self.dimensiones[0] * self.dimensiones[1] *
                      self.dimensiones[2]) / 1000000

        # El mayor entre peso volumÃ©trico y peso real
        peso_volumetrico = volumen_m3 * 200  # Factor estÃ¡ndar
        peso_cobrable = max(self.peso_kg, peso_volumetrico)

        return costo_base + (peso_cobrable * costo_por_kg)

    def puede_ser_enviado(self) -> bool:
        """Productos fÃ­sicos siempre requieren envÃ­o"""
        return True

    def obtener_tipo(self) -> TipoProducto:
        return TipoProducto.FISICO

    def obtener_dimensiones_str(self) -> str:
        """Retorna las dimensiones en formato legible"""
        return f"{self.dimensiones[0]}x{self.dimensiones[1]}x{self.dimensiones[2]} cm"


class ProductoDigital(Producto):
    """
    Producto digital descargable (no requiere envÃ­o).
    Ejemplos: software, ebooks, cursos online, mÃºsica.
    """

    def __init__(self, nombre: str, descripcion: str, precio: float,
                 tamaÃ±o_mb: float, formato: str, url_descarga: str = "",
                 stock_disponible: int = 999999):
        """
        Inicializa un producto digital.

        Args:
            nombre (str): Nombre del producto
            descripcion (str): DescripciÃ³n
            precio (float): Precio
            tamaÃ±o_mb (float): TamaÃ±o del archivo en MB
            formato (str): Formato del archivo (PDF, MP3, MP4, etc.)
            url_descarga (str): URL de descarga
            stock_disponible (int): Stock "ilimitado" por defecto
        """
        super().__init__(nombre, descripcion, precio, stock_disponible)
        self.tamaÃ±o_mb = tamaÃ±o_mb
        self.formato = formato
        self.url_descarga = url_descarga
        self.licencia = self._generar_licencia()

    def _generar_licencia(self) -> str:
        """Genera un cÃ³digo de licencia Ãºnico"""
        return f"LIC-{uuid.uuid4().hex[:12].upper()}"

    def calcular_costo_total(self, cantidad: int) -> float:
        """
        Calcula costo total (puede tener descuentos por volumen).

        Args:
            cantidad (int): Cantidad de licencias

        Returns:
            float: Costo total con descuento si aplica
        """
        costo_base = self.precio * cantidad

        # Descuento por volumen
        if cantidad >= 10:
            descuento = 0.15  # 15% descuento
        elif cantidad >= 5:
            descuento = 0.10  # 10% descuento
        else:
            descuento = 0

        return costo_base * (1 - descuento)

    def puede_ser_enviado(self) -> bool:
        """Productos digitales no requieren envÃ­o fÃ­sico"""
        return False

    def obtener_tipo(self) -> TipoProducto:
        return TipoProducto.DIGITAL

    def generar_enlace_descarga(self) -> str:
        """Genera un enlace de descarga temporal"""
        token = uuid.uuid4().hex
        return f"{self.url_descarga}?token={token}&licencia={self.licencia}"


class Servicio(Producto):
    """
    Servicio contratado (no tiene stock fÃ­sico).
    Ejemplos: consultorÃ­a, mantenimiento, soporte tÃ©cnico.
    """

    def __init__(self, nombre: str, descripcion: str, precio_hora: float,
                 horas_estimadas: float, disponibilidad: bool = True):
        """
        Inicializa un servicio.

        Args:
            nombre (str): Nombre del servicio
            descripcion (str): DescripciÃ³n
            precio_hora (float): Precio por hora
            horas_estimadas (float): Horas estimadas del servicio
            disponibilidad (bool): Si el servicio estÃ¡ disponible
        """
        precio_total = precio_hora * horas_estimadas
        super().__init__(nombre, descripcion, precio_total,
                        stock_disponible=1 if disponibilidad else 0)
        self.precio_hora = precio_hora
        self.horas_estimadas = horas_estimadas
        self.fecha_programada: Optional[datetime] = None

    def calcular_costo_total(self, cantidad: int = 1) -> float:
        """
        Calcula el costo total del servicio.
        Para servicios, cantidad suele ser 1.

        Args:
            cantidad (int): NÃºmero de servicios (usualmente 1)

        Returns:
            float: Costo total
        """
        return self.precio * cantidad

    def programar_servicio(self, fecha: datetime):
        """Programa la fecha del servicio"""
        self.fecha_programada = fecha
        print(f"âœ“ Servicio '{self.nombre}' programado para {fecha.strftime('%d/%m/%Y %H:%M')}")

    def puede_ser_enviado(self) -> bool:
        """Los servicios no requieren envÃ­o"""
        return False

    def obtener_tipo(self) -> TipoProducto:
        return TipoProducto.SERVICIO

    def calcular_costo_con_horas_extra(self, horas_adicionales: float) -> float:
        """Calcula el costo si se requieren horas adicionales"""
        costo_extra = horas_adicionales * self.precio_hora * 1.5  # 50% mÃ¡s caro
        return self.precio + costo_extra


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARTE 2: COMPOSICIÃ“N - COMPONENTES DEL SISTEMA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class DireccionEnvio:
    """
    Representa una direcciÃ³n de envÃ­o.
    Usado en COMPOSICIÃ“N: Pedido TIENE UNA DireccionEnvio
    """
    calle: str
    numero: str
    colonia: str
    ciudad: str
    estado: str
    codigo_postal: str
    referencias: str = ""

    def __str__(self) -> str:
        return (f"{self.calle} #{self.numero}, {self.colonia}\n"
                f"{self.ciudad}, {self.estado} CP {self.codigo_postal}")

    def direccion_completa(self) -> str:
        """Retorna la direcciÃ³n en una sola lÃ­nea"""
        return f"{self.calle} {self.numero}, {self.colonia}, {self.ciudad}, {self.estado}, CP {self.codigo_postal}"


@dataclass
class MetodoPago:
    """
    Representa un mÃ©todo de pago.
    Usado en COMPOSICIÃ“N: Pedido TIENE UN MetodoPago
    """
    tipo: str  # "tarjeta", "transferencia", "efectivo", etc.
    titular: str
    ultimos_digitos: str = ""

    def __str__(self) -> str:
        if self.ultimos_digitos:
            return f"{self.tipo.title()} - {self.titular} (****{self.ultimos_digitos})"
        return f"{self.tipo.title()} - {self.titular}"


class ItemCarrito:
    """
    Representa un item en el carrito de compras.
    Usado en COMPOSICIÃ“N: Carrito TIENE mÃºltiples ItemCarrito
    """

    def __init__(self, producto: Producto, cantidad: int):
        """
        Inicializa un item del carrito.

        Args:
            producto (Producto): Producto a agregar
            cantidad (int): Cantidad del producto
        """
        if not isinstance(producto, Producto):
            raise TypeError("Solo se pueden agregar objetos Producto")

        if cantidad <= 0:
            raise ValueError("La cantidad debe ser positiva")

        if not producto.verificar_disponibilidad(cantidad):
            raise ValueError(f"Stock insuficiente para {producto.nombre}")

        self.producto = producto
        self.cantidad = cantidad
        self.precio_unitario = producto.precio
        self.fecha_agregado = datetime.now()

    def calcular_subtotal(self) -> float:
        """Calcula el subtotal del item"""
        return self.producto.calcular_costo_total(self.cantidad)

    def actualizar_cantidad(self, nueva_cantidad: int):
        """Actualiza la cantidad del item"""
        if nueva_cantidad <= 0:
            raise ValueError("La cantidad debe ser positiva")

        if not self.producto.verificar_disponibilidad(nueva_cantidad):
            raise ValueError(f"Stock insuficiente para {self.producto.nombre}")

        self.cantidad = nueva_cantidad

    def __str__(self) -> str:
        return (f"{self.producto.nombre} x{self.cantidad} - "
                f"${self.calcular_subtotal():,.2f}")


class Carrito:
    """
    Carrito de compras.
    COMPOSICIÃ“N: Carrito TIENE mÃºltiples ItemCarrito
    """

    def __init__(self):
        """Inicializa un carrito vacÃ­o"""
        self.items: List[ItemCarrito] = []
        self.fecha_creacion = datetime.now()

    def agregar_producto(self, producto: Producto, cantidad: int = 1):
        """
        Agrega un producto al carrito.

        Args:
            producto (Producto): Producto a agregar
            cantidad (int): Cantidad a agregar
        """
        # Verificar si el producto ya estÃ¡ en el carrito
        for item in self.items:
            if item.producto.id == producto.id:
                item.actualizar_cantidad(item.cantidad + cantidad)
                print(f"âœ“ Cantidad actualizada: {item}")
                return

        # Si no estÃ¡, crear nuevo item
        item = ItemCarrito(producto, cantidad)
        self.items.append(item)
        print(f"âœ“ Producto agregado: {item}")

    def eliminar_producto(self, producto_id: str) -> bool:
        """
        Elimina un producto del carrito.

        Args:
            producto_id (str): ID del producto a eliminar

        Returns:
            bool: True si se eliminÃ³
        """
        for i, item in enumerate(self.items):
            if item.producto.id == producto_id:
                eliminado = self.items.pop(i)
                print(f"âœ“ Producto eliminado: {eliminado.producto.nombre}")
                return True

        print(f"âœ— Producto no encontrado en el carrito")
        return False

    def vaciar(self):
        """VacÃ­a el carrito"""
        self.items.clear()
        print("âœ“ Carrito vaciado")

    def calcular_subtotal(self) -> float:
        """Calcula el subtotal de todos los items"""
        return sum(item.calcular_subtotal() for item in self.items)

    def calcular_total_envio(self, direccion: DireccionEnvio) -> float:
        """
        Calcula el costo total de envÃ­o para productos fÃ­sicos.

        Args:
            direccion (DireccionEnvio): DirecciÃ³n de envÃ­o

        Returns:
            float: Costo total de envÃ­o
        """
        total_envio = 0

        for item in self.items:
            if isinstance(item.producto, ProductoFisico):
                costo = item.producto.calcular_costo_envio(direccion.codigo_postal)
                total_envio += costo * item.cantidad

        return total_envio

    def calcular_total(self, direccion: Optional[DireccionEnvio] = None) -> float:
        """
        Calcula el total incluyendo envÃ­o si aplica.

        Args:
            direccion (DireccionEnvio, optional): DirecciÃ³n para calcular envÃ­o

        Returns:
            float: Total a pagar
        """
        subtotal = self.calcular_subtotal()

        if direccion:
            envio = self.calcular_total_envio(direccion)
            return subtotal + envio

        return subtotal

    def obtener_resumen(self) -> Dict:
        """Retorna un resumen del carrito"""
        return {
            "total_items": len(self.items),
            "total_productos": sum(item.cantidad for item in self.items),
            "subtotal": self.calcular_subtotal(),
            "productos_fisicos": sum(1 for item in self.items
                                    if isinstance(item.producto, ProductoFisico)),
            "productos_digitales": sum(1 for item in self.items
                                      if isinstance(item.producto, ProductoDigital)),
            "servicios": sum(1 for item in self.items
                            if isinstance(item.producto, Servicio))
        }

    def __len__(self) -> int:
        """Retorna la cantidad de items diferentes"""
        return len(self.items)

    def __str__(self) -> str:
        if not self.items:
            return "Carrito vacÃ­o"

        lineas = ["CARRITO DE COMPRAS", "â”€" * 60]
        for i, item in enumerate(self.items, 1):
            lineas.append(f"{i}. {item}")
        lineas.append("â”€" * 60)
        lineas.append(f"SUBTOTAL: ${self.calcular_subtotal():,.2f}")

        return "\n".join(lineas)


class Pedido:
    """
    Representa un pedido completo.
    COMPOSICIÃ“N: Pedido TIENE UN Carrito, UNA DireccionEnvio, UN MetodoPago
    """

    _contador = 0

    def __init__(self, cliente_nombre: str, carrito: Carrito,
                 direccion: DireccionEnvio, metodo_pago: MetodoPago):
        """
        Inicializa un pedido.

        Args:
            cliente_nombre (str): Nombre del cliente
            carrito (Carrito): Carrito con los productos
            direccion (DireccionEnvio): DirecciÃ³n de envÃ­o
            metodo_pago (MetodoPago): MÃ©todo de pago
        """
        if not carrito.items:
            raise ValueError("No se puede crear un pedido con carrito vacÃ­o")

        Pedido._contador += 1
        self.numero_pedido = f"PED-{datetime.now().strftime('%Y%m%d')}-{Pedido._contador:05d}"
        self.cliente_nombre = cliente_nombre

        # COMPOSICIÃ“N: El pedido contiene estos objetos
        self.carrito = carrito
        self.direccion_envio = direccion
        self.metodo_pago = metodo_pago

        self.fecha_pedido = datetime.now()
        self.estado = EstadoPedido.PENDIENTE
        self.fecha_envio: Optional[datetime] = None
        self.fecha_entrega: Optional[datetime] = None
        self.numero_rastreo: Optional[str] = None

        # Calcular totales
        self.subtotal = carrito.calcular_subtotal()
        self.costo_envio = carrito.calcular_total_envio(direccion)
        self.total = self.subtotal + self.costo_envio

    def procesar_pago(self) -> bool:
        """
        Procesa el pago del pedido.

        Returns:
            bool: True si el pago fue exitoso
        """
        # AquÃ­ irÃ­a la lÃ³gica de procesamiento de pago real
        print(f"\nğŸ’³ Procesando pago de ${self.total:,.2f}...")
        print(f"   MÃ©todo: {self.metodo_pago}")

        # Simular procesamiento exitoso
        self.estado = EstadoPedido.PAGADO
        print("âœ“ Pago procesado exitosamente")

        # Reducir stock de productos
        for item in self.carrito.items:
            item.producto.reducir_stock(item.cantidad)

        return True

    def marcar_como_enviado(self, numero_rastreo: str):
        """Marca el pedido como enviado"""
        if self.estado != EstadoPedido.PAGADO:
            raise ValueError("El pedido debe estar pagado para poder enviarse")

        self.estado = EstadoPedido.ENVIADO
        self.fecha_envio = datetime.now()
        self.numero_rastreo = numero_rastreo
        print(f"âœ“ Pedido {self.numero_pedido} enviado. Rastreo: {numero_rastreo}")

    def marcar_como_entregado(self):
        """Marca el pedido como entregado"""
        if self.estado != EstadoPedido.ENVIADO:
            raise ValueError("El pedido debe estar enviado para poder marcarse como entregado")

        self.estado = EstadoPedido.ENTREGADO
        self.fecha_entrega = datetime.now()
        print(f"âœ“ Pedido {self.numero_pedido} entregado")

    def cancelar(self, razon: str = ""):
        """Cancela el pedido"""
        if self.estado in [EstadoPedido.ENVIADO, EstadoPedido.ENTREGADO]:
            raise ValueError("No se puede cancelar un pedido ya enviado o entregado")

        self.estado = EstadoPedido.CANCELADO
        print(f"âœ“ Pedido {self.numero_pedido} cancelado. RazÃ³n: {razon}")

        # Restaurar stock si ya estaba pagado
        if self.estado == EstadoPedido.PAGADO:
            for item in self.carrito.items:
                item.producto.aumentar_stock(item.cantidad)

    def generar_ticket(self) -> str:
        """Genera un ticket de compra"""
        ticket = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     TICKET DE COMPRA                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PEDIDO: {self.numero_pedido}
FECHA:  {self.fecha_pedido.strftime('%d/%m/%Y %H:%M')}
CLIENTE: {self.cliente_nombre}
ESTADO: {self.estado.value}

{'â”€' * 62}
PRODUCTOS:
{'â”€' * 62}
"""

        for i, item in enumerate(self.carrito.items, 1):
            ticket += f"{i}. {item.producto.nombre:<40} x{item.cantidad:>3}\n"
            ticket += f"   ${item.precio_unitario:>10,.2f} c/u  Subtotal: ${item.calcular_subtotal():>10,.2f}\n"

        ticket += f"""
{'â”€' * 62}
SUBTOTAL:        ${self.subtotal:>43,.2f}
ENVÃO:           ${self.costo_envio:>43,.2f}
{'â•' * 62}
TOTAL:           ${self.total:>43,.2f}
{'â•' * 62}

DIRECCIÃ“N DE ENVÃO:
{self.direccion_envio}

MÃ‰TODO DE PAGO:
{self.metodo_pago}
"""

        if self.numero_rastreo:
            ticket += f"\nNÃšMERO DE RASTREO: {self.numero_rastreo}\n"

        ticket += "\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"

        return ticket

    def __str__(self) -> str:
        return f"Pedido {self.numero_pedido} - {self.estado.value} - ${self.total:,.2f}"


class Cliente:
    """
    Representa un cliente del sistema.
    COMPOSICIÃ“N: Cliente TIENE mÃºltiples Direcciones, MetodosPago y Pedidos
    """

    def __init__(self, nombre: str, email: str, telefono: str):
        """
        Inicializa un cliente.

        Args:
            nombre (str): Nombre completo
            email (str): Correo electrÃ³nico
            telefono (str): TelÃ©fono de contacto
        """
        self.id = f"CLI-{uuid.uuid4().hex[:8].upper()}"
        self.nombre = nombre
        self.email = email
        self.telefono = telefono
        self.fecha_registro = datetime.now()

        # COMPOSICIÃ“N: El cliente contiene estas colecciones
        self.direcciones: List[DireccionEnvio] = []
        self.metodos_pago: List[MetodoPago] = []
        self.historial_pedidos: List[Pedido] = []

        # Carrito activo del cliente
        self.carrito_actual = Carrito()

    def agregar_direccion(self, direccion: DireccionEnvio):
        """Agrega una direcciÃ³n al cliente"""
        self.direcciones.append(direccion)
        print(f"âœ“ DirecciÃ³n agregada para {self.nombre}")

    def agregar_metodo_pago(self, metodo: MetodoPago):
        """Agrega un mÃ©todo de pago"""
        self.metodos_pago.append(metodo)
        print(f"âœ“ MÃ©todo de pago agregado: {metodo.tipo}")

    def crear_pedido(self, indice_direccion: int = 0,
                    indice_metodo_pago: int = 0) -> Pedido:
        """
        Crea un pedido con el carrito actual.

        Args:
            indice_direccion (int): Ãndice de la direcciÃ³n a usar
            indice_metodo_pago (int): Ãndice del mÃ©todo de pago a usar

        Returns:
            Pedido: Pedido creado
        """
        if not self.direcciones:
            raise ValueError("El cliente no tiene direcciones registradas")

        if not self.metodos_pago:
            raise ValueError("El cliente no tiene mÃ©todos de pago registrados")

        if not self.carrito_actual.items:
            raise ValueError("El carrito estÃ¡ vacÃ­o")

        direccion = self.direcciones[indice_direccion]
        metodo = self.metodos_pago[indice_metodo_pago]

        pedido = Pedido(self.nombre, self.carrito_actual, direccion, metodo)
        self.historial_pedidos.append(pedido)

        # Crear nuevo carrito para siguientes compras
        self.carrito_actual = Carrito()

        print(f"âœ“ Pedido {pedido.numero_pedido} creado")

        return pedido

    def obtener_total_gastado(self) -> float:
        """Calcula el total gastado por el cliente"""
        return sum(
            pedido.total
            for pedido in self.historial_pedidos
            if pedido.estado in [EstadoPedido.PAGADO, EstadoPedido.ENVIADO,
                                EstadoPedido.ENTREGADO]
        )

    def obtener_pedidos_activos(self) -> List[Pedido]:
        """Retorna pedidos que no han sido entregados o cancelados"""
        return [
            pedido for pedido in self.historial_pedidos
            if pedido.estado not in [EstadoPedido.ENTREGADO, EstadoPedido.CANCELADO]
        ]

    def __str__(self) -> str:
        return f"{self.nombre} ({self.email}) - {len(self.historial_pedidos)} pedidos"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEMOSTRACIÃ“N COMPLETA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """DemostraciÃ³n completa del sistema de e-commerce"""

    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘              SISTEMA DE E-COMMERCE COMPLETO                  â•‘")
    print("â•‘         Herencia y ComposiciÃ³n en AcciÃ³n                     â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. CREAR PRODUCTOS (USANDO HERENCIA)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("1. CREANDO PRODUCTOS (JerarquÃ­a de Herencia)")
    print("â”€" * 63)

    # Productos fÃ­sicos
    laptop = ProductoFisico(
        nombre="Laptop Dell XPS 15",
        descripcion="Laptop profesional con i7 y 16GB RAM",
        precio=25000,
        peso_kg=2.5,
        dimensiones=(35, 25, 2),
        stock_disponible=10
    )

    mouse = ProductoFisico(
        nombre="Mouse Logitech MX Master 3",
        descripcion="Mouse inalÃ¡mbrico ergonÃ³mico",
        precio=1500,
        peso_kg=0.15,
        dimensiones=(12, 8, 5),
        stock_disponible=50
    )

    # Productos digitales
    curso_python = ProductoDigital(
        nombre="Curso Completo de Python",
        descripcion="Aprende Python desde cero hasta avanzado",
        precio=599,
        tamaÃ±o_mb=2500,
        formato="MP4",
        url_descarga="https://cursos.example.com/python"
    )

    ebook = ProductoDigital(
        nombre="eBook: Clean Code en Python",
        descripcion="GuÃ­a completa de buenas prÃ¡cticas",
        precio=299,
        tamaÃ±o_mb=15,
        formato="PDF"
    )

    # Servicios
    consultoria = Servicio(
        nombre="ConsultorÃ­a de Arquitectura de Software",
        descripcion="SesiÃ³n de consultorÃ­a con experto",
        precio_hora=1500,
        horas_estimadas=4
    )

    productos = [laptop, mouse, curso_python, ebook, consultoria]

    for prod in productos:
        tipo = prod.obtener_tipo().value
        envio = "Requiere envÃ­o" if prod.puede_ser_enviado() else "Sin envÃ­o"
        print(f"âœ“ [{tipo:10}] {prod.nombre[:35]:<35} - ${prod.precio:>8,.2f} | {envio}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. CREAR CLIENTE (USANDO COMPOSICIÃ“N)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n2. CREANDO CLIENTE (ComposiciÃ³n de Datos)")
    print("â”€" * 63)

    cliente = Cliente(
        nombre="Ana MarÃ­a GonzÃ¡lez",
        email="ana.gonzalez@email.com",
        telefono="555-1234-5678"
    )

    print(f"âœ“ Cliente creado: {cliente}")

    # Agregar direcciÃ³n (COMPOSICIÃ“N)
    direccion_casa = DireccionEnvio(
        calle="Av. Insurgentes Sur",
        numero="1234",
        colonia="Del Valle",
        ciudad="Ciudad de MÃ©xico",
        estado="CDMX",
        codigo_postal="03100",
        referencias="Entre calles A y B"
    )

    cliente.agregar_direccion(direccion_casa)

    # Agregar mÃ©todo de pago (COMPOSICIÃ“N)
    tarjeta = MetodoPago(
        tipo="tarjeta",
        titular="Ana MarÃ­a GonzÃ¡lez",
        ultimos_digitos="4532"
    )

    cliente.agregar_metodo_pago(tarjeta)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. AGREGAR PRODUCTOS AL CARRITO
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n3. LLENANDO CARRITO DE COMPRAS")
    print("â”€" * 63)

    cliente.carrito_actual.agregar_producto(laptop, 1)
    cliente.carrito_actual.agregar_producto(mouse, 2)
    cliente.carrito_actual.agregar_producto(curso_python, 1)
    cliente.carrito_actual.agregar_producto(ebook, 1)

    print(f"\n{cliente.carrito_actual}")

    # Resumen del carrito
    print("\nğŸ“Š Resumen del carrito:")
    resumen = cliente.carrito_actual.obtener_resumen()
    for key, value in resumen.items():
        print(f"  {key.replace('_', ' ').title()}: {value}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. CREAR PEDIDO (COMPOSICIÃ“N DE OBJETOS)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n4. CREANDO PEDIDO (ComposiciÃ³n Compleja)")
    print("â”€" * 63)

    pedido = cliente.crear_pedido(indice_direccion=0, indice_metodo_pago=0)

    print(f"\n{pedido}")
    print(f"  Subtotal: ${pedido.subtotal:,.2f}")
    print(f"  EnvÃ­o:    ${pedido.costo_envio:,.2f}")
    print(f"  Total:    ${pedido.total:,.2f}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. PROCESAR PEDIDO
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n5. PROCESANDO PEDIDO")
    print("â”€" * 63)

    # Procesar pago
    pedido.procesar_pago()

    # Enviar
    pedido.marcar_como_enviado("TRACK-2024-XYZ789")

    # Entregar
    pedido.marcar_como_entregado()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. GENERAR TICKET
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n\n6. TICKET DE COMPRA")
    print("â”€" * 63)

    print(pedido.generar_ticket())

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7. HISTORIAL DEL CLIENTE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n7. HISTORIAL DEL CLIENTE")
    print("â”€" * 63)

    print(f"\nCliente: {cliente.nombre}")
    print(f"Total gastado: ${cliente.obtener_total_gastado():,.2f}")
    print(f"Pedidos totales: {len(cliente.historial_pedidos)}")
    print(f"Pedidos activos: {len(cliente.obtener_pedidos_activos())}")

    print("\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


if __name__ == "__main__":
    main()
```

## ğŸ” ExplicaciÃ³n Detallada

### HERENCIA: JerarquÃ­a de Productos

```python
class Producto(ABC):  # Clase base abstracta
    @abstractmethod
    def calcular_costo_total(self, cantidad: int) -> float:
        pass  # Cada subclase lo implementa diferente

class ProductoFisico(Producto):  # Herencia
    def calcular_costo_total(self, cantidad: int) -> float:
        return self.precio * cantidad  # ImplementaciÃ³n especÃ­fica
```

**Ventajas:**

- âœ… ReutilizaciÃ³n de cÃ³digo (atributos y mÃ©todos comunes)
- âœ… Polimorfismo (tratar diferentes tipos como Producto)
- âœ… JerarquÃ­a clara de relaciones "es un"

### COMPOSICIÃ“N: Ensamblaje de Objetos

```python
class Pedido:
    def __init__(self, ..., carrito: Carrito,
                 direccion: DireccionEnvio, metodo_pago: MetodoPago):
        # COMPOSICIÃ“N: El pedido "tiene" estos objetos
        self.carrito = carrito
        self.direccion_envio = direccion
        self.metodo_pago = metodo_pago
```

**Ventajas:**

- âœ… Mayor flexibilidad (componentes intercambiables)
- âœ… Menor acoplamiento
- âœ… FÃ¡cil de probar y mantener
- âœ… Favorece reutilizaciÃ³n

## âœ… Puntos Clave para Replicar

1. **Usar herencia para relaciones "es un"**: ProductoFisico ES UN Producto
2. **Usar composiciÃ³n para relaciones "tiene un"**: Pedido TIENE UN Carrito
3. **Clases abstractas con ABC**: Forzar implementaciÃ³n de mÃ©todos
4. **Polimorfismo**: Tratar diferentes subclases de forma uniforme
5. **Super()**: Llamar a mÃ©todos de la clase padre
6. **Enums**: Para estados y tipos predefinidos
7. **Dataclasses**: Para objetos de datos simples
8. **Type hints**: Documentar tipos esperados

## ğŸ“ Conceptos Aplicados

- âœ… Herencia con ABC
- âœ… Clases abstractas y mÃ©todos abstractos
- âœ… ComposiciÃ³n de objetos
- âœ… Polimorfismo
- âœ… Enumeraciones (Enum)
- âœ… Dataclasses
- âœ… Type hints completos
- âœ… MÃ©todos especiales
- âœ… Validaciones robustas
- âœ… Principio de responsabilidad Ãºnica

## ğŸš€ Extensiones Posibles

1. Persistencia en base de datos (SQLAlchemy)
2. API REST con FastAPI
3. Sistema de reseÃ±as y calificaciones
4. Cupones de descuento
5. Sistema de puntos/recompensas
6. Notificaciones por email/SMS
7. Panel de administraciÃ³n
8. IntegraciÃ³n con pagos reales (Stripe, PayPal)
9. Sistema de devoluciones
10. AnÃ¡lisis de ventas y estadÃ­sticas
